import fs from 'fs-extra';
import path from 'path';

/**
 * Attachment interface for files/images passed with prompts
 */
export interface Attachment {
  path: string;
  name: string;
  type: string;
}

/**
 * PromptLogger - Automatic logging of user prompts to increment logs
 *
 * Features:
 * - Logs every user prompt to appropriate increment's logs/ folder
 * - Organized by day (YYYY-MM-DD)
 * - Preserves exact prompt text (character-for-character)
 * - Copies attachments to assets/ subfolder
 * - Smart increment detection (active increments)
 * - Fallback to orphaned logs if no active increment
 */
export class PromptLogger {
  constructor(private workingDir: string) {}

  /**
   * Log a user prompt to the daily session file
   *
   * @param promptText - Exact user prompt text
   * @param attachments - Optional attachments (images, files)
   */
  async logPrompt(
    promptText: string,
    attachments: Attachment[] = []
  ): Promise<void> {
    // Find appropriate increment for logging
    const incrementId = await this.findIncrementForLogging();

    // Determine log directory
    const logDir = incrementId
      ? path.join(this.workingDir, '.specweave/increments', incrementId, 'logs')
      : path.join(this.workingDir, '.specweave/logs/orphaned');

    // Get current date for daily organization
    const now = new Date();
    const dateStr = now.toISOString().slice(0, 10); // YYYY-MM-DD
    const dailyDir = path.join(logDir, dateStr);
    const assetsDir = path.join(dailyDir, 'assets');

    // Ensure directories exist
    await fs.ensureDir(assetsDir);

    // Session file path
    const sessionFile = path.join(dailyDir, 'session.md');

    // Create session file header if new file
    if (!await fs.pathExists(sessionFile)) {
      const header = this.createSessionHeader(dateStr, incrementId);
      await fs.writeFile(sessionFile, header);
    }

    // Build prompt entry
    const time = now.toTimeString().slice(0, 8); // HH:MM:SS
    const entry = this.buildPromptEntry(time, promptText, attachments);

    // Append to session file (atomic operation)
    await fs.appendFile(sessionFile, entry);

    // Copy attachments to assets/
    if (attachments.length > 0) {
      await this.copyAttachments(attachments, assetsDir);
    }

    // Create/update README.md in logs/ folder
    await this.ensureLogsReadme(path.dirname(dailyDir));
  }

  /**
   * Create session file header
   */
  private createSessionHeader(date: string, incrementId: string | null): string {
    const location = incrementId
      ? `Increment: ${incrementId}`
      : 'Location: Orphaned logs (no active increment)';

    return `# Session Log - ${date}

Generated by SpecWeave automatic prompt logging.
${location}

---

`;
  }

  /**
   * Build a single prompt entry
   */
  private buildPromptEntry(
    time: string,
    promptText: string,
    attachments: Attachment[]
  ): string {
    let entry = `## ${time} - User Prompt\n\n`;
    entry += `${promptText}\n\n`;

    if (attachments.length > 0) {
      entry += `**Attachments**:\n`;
      attachments.forEach((att, idx) => {
        const assetFilename = this.getAssetFilename(att, idx + 1);
        entry += `- \`assets/${assetFilename}\` - ${att.name}\n`;
      });
    } else {
      entry += `**Attachments**: None\n`;
    }

    entry += `\n---\n\n`;
    return entry;
  }

  /**
   * Copy attachments to assets folder
   */
  private async copyAttachments(
    attachments: Attachment[],
    assetsDir: string
  ): Promise<void> {
    for (let i = 0; i < attachments.length; i++) {
      const att = attachments[i];
      const destFilename = this.getAssetFilename(att, i + 1);
      const destPath = path.join(assetsDir, destFilename);

      try {
        await fs.copy(att.path, destPath);
      } catch (error) {
        console.error(`Failed to copy attachment ${att.name}:`, error);
        // Continue with other attachments
      }
    }
  }

  /**
   * Generate numbered asset filename
   */
  private getAssetFilename(att: Attachment, index: number): string {
    const ext = path.extname(att.name);
    const typePrefix = this.getTypePrefix(att.type);
    const paddedIndex = String(index).padStart(3, '0');

    return `${typePrefix}-${paddedIndex}${ext}`;
  }

  /**
   * Get prefix based on file type
   */
  private getTypePrefix(type: string): string {
    if (type.startsWith('image/')) return 'screenshot';
    if (type === 'application/pdf') return 'document';
    if (type.startsWith('text/')) return 'text';
    return 'file';
  }

  /**
   * Find the appropriate increment for logging
   *
   * Priority:
   * 1. Most recently modified active increment (if multiple active)
   * 2. Single active increment
   * 3. null (log to orphaned/)
   *
   * @returns Increment ID or null for orphaned logs
   */
  private async findIncrementForLogging(): Promise<string | null> {
    const incrementsDir = path.join(this.workingDir, '.specweave/increments');

    if (!await fs.pathExists(incrementsDir)) {
      return null;
    }

    // Find all active increments
    const activeIncrements: Array<{ id: string; lastActivity: Date }> = [];

    const dirs = await fs.readdir(incrementsDir);

    for (const dir of dirs) {
      const metadataPath = path.join(incrementsDir, dir, 'metadata.json');

      if (await fs.pathExists(metadataPath)) {
        try {
          const metadata = await fs.readJson(metadataPath);

          if (metadata.status === 'active') {
            const lastActivity = new Date(
              metadata.lastActivity || metadata.created || Date.now()
            );

            activeIncrements.push({
              id: dir,
              lastActivity
            });
          }
        } catch (error) {
          // Skip invalid metadata files
          continue;
        }
      }
    }

    // No active increments → orphaned logs
    if (activeIncrements.length === 0) {
      return null;
    }

    // Single active → use it
    if (activeIncrements.length === 1) {
      return activeIncrements[0].id;
    }

    // Multiple active (max 2 allowed) → use most recent
    activeIncrements.sort((a, b) =>
      b.lastActivity.getTime() - a.lastActivity.getTime()
    );

    return activeIncrements[0].id;
  }

  /**
   * Ensure README.md exists in logs/ folder
   */
  private async ensureLogsReadme(logsDir: string): Promise<void> {
    const readmePath = path.join(logsDir, 'README.md');

    // Only create if doesn't exist
    if (await fs.pathExists(readmePath)) {
      return;
    }

    const readme = this.createLogsReadme();
    await fs.writeFile(readmePath, readme);
  }

  /**
   * Create README.md content for logs/ folder
   */
  private createLogsReadme(): string {
    const now = new Date().toISOString().replace('T', ' ').slice(0, 19);

    return `# Prompt Logs

This folder contains automatic logs of all user prompts for this increment.

## Structure

\`\`\`
logs/
├── 2025-11-13/
│   ├── session.md      # All prompts for this day
│   └── assets/         # Images, screenshots, files
├── 2025-11-14/
│   └── session.md
└── README.md           # This file
\`\`\`

## Purpose

- **Audit trail**: Review what was asked and when
- **Context preservation**: Understand past decisions
- **Debug tool**: Trace where certain implementations came from
- **Knowledge base**: Search past conversations

## Privacy Note

These logs contain YOUR prompts exactly as typed. They may include:
- Code snippets
- API keys or secrets (review before committing!)
- Personal information
- Project-specific details

**Recommendation**: Review logs before committing to git.

## Configuration

To disable logging, edit \`.specweave/config.json\`:

\`\`\`json
{
  "logging": {
    "enabled": false
  }
}
\`\`\`

## Generated by SpecWeave

Last updated: ${now}
`;
  }
}
