/**
 * Environment File Generator
 *
 * Generates .env files with GitHub configuration for sync.
 * Handles security (gitignore, permissions) and multi-provider support.
 *
 * Features:
 * - Auto-generate .env with GitHub config
 * - Add .env to .gitignore automatically
 * - Create .env.example for team sharing
 * - Multi-provider support (GitHub, JIRA, ADO)
 *
 * @module env-file-generator
 */

import fs from 'fs-extra';
import path from 'path';

/**
 * Repository mapping
 */
export interface RepoMapping {
  id: string;
  repo: string;
}

/**
 * Environment configuration
 */
export interface EnvConfig {
  githubToken?: string;
  githubOwner?: string;
  repos?: RepoMapping[];
  syncEnabled?: boolean;
  autoCreateIssue?: boolean;
  syncDirection?: 'bidirectional' | 'export' | 'import';
}

/**
 * Generate .env file with GitHub configuration
 *
 * @param projectRoot - Project root directory
 * @param config - Environment configuration
 */
export async function generateEnvFile(
  projectRoot: string,
  config: EnvConfig
): Promise<void> {
  const envPath = path.join(projectRoot, '.env');
  const envExamplePath = path.join(projectRoot, '.env.example');

  // Build .env content
  const content = buildEnvContent(config);
  const exampleContent = buildEnvExampleContent();

  // Write .env file
  await fs.writeFile(envPath, content, 'utf-8');

  // Set secure permissions (owner read/write only)
  if (process.platform !== 'win32') {
    await fs.chmod(envPath, 0o600);
  }

  // Write .env.example
  await fs.writeFile(envExamplePath, exampleContent, 'utf-8');

  // Update .gitignore
  await updateGitignore(projectRoot);
}

/**
 * Build .env file content
 *
 * @param config - Environment configuration
 * @returns .env content
 */
function buildEnvContent(config: EnvConfig): string {
  const lines: string[] = [];

  lines.push('# GitHub Configuration (Auto-generated by SpecWeave)');
  lines.push(`# Created: ${new Date().toISOString()}`);
  lines.push('');

  // GitHub token
  if (config.githubToken) {
    lines.push(`GITHUB_TOKEN=${config.githubToken}`);
  } else {
    lines.push('GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx');
  }

  // GitHub owner
  if (config.githubOwner) {
    lines.push(`GITHUB_OWNER=${config.githubOwner}`);
  } else {
    lines.push('GITHUB_OWNER=myorg');
  }

  lines.push('');
  lines.push('# Repository Mapping (id:repo-name)');

  // Repos
  if (config.repos && config.repos.length > 0) {
    const repoMappings = config.repos.map(r => `${r.id}:${r.repo}`).join(',');
    lines.push(`GITHUB_REPOS=${repoMappings}`);
  } else {
    lines.push('GITHUB_REPOS=parent:my-project-parent,frontend:my-project-frontend,backend:my-project-backend');
  }

  lines.push('');
  lines.push('# Sync Configuration');
  lines.push(`GITHUB_SYNC_ENABLED=${config.syncEnabled !== false ? 'true' : 'false'}`);
  lines.push(`GITHUB_AUTO_CREATE_ISSUE=${config.autoCreateIssue !== false ? 'true' : 'false'}`);
  lines.push(`GITHUB_SYNC_DIRECTION=${config.syncDirection || 'bidirectional'}`);

  return lines.join('\n') + '\n';
}

/**
 * Build .env.example file content
 *
 * @returns .env.example content
 */
function buildEnvExampleContent(): string {
  const lines: string[] = [];

  lines.push('# GitHub Configuration');
  lines.push('# Copy this file to .env and fill in your values');
  lines.push('');
  lines.push('# GitHub Personal Access Token (get from https://github.com/settings/tokens)');
  lines.push('GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx');
  lines.push('');
  lines.push('# GitHub owner (user or organization)');
  lines.push('GITHUB_OWNER=your-username-or-org');
  lines.push('');
  lines.push('# Repository Mapping (id:repo-name,id:repo-name,...)');
  lines.push('GITHUB_REPOS=parent:my-project-parent,frontend:my-project-frontend,backend:my-project-backend');
  lines.push('');
  lines.push('# Sync Configuration');
  lines.push('GITHUB_SYNC_ENABLED=true');
  lines.push('GITHUB_AUTO_CREATE_ISSUE=true');
  lines.push('GITHUB_SYNC_DIRECTION=bidirectional');

  return lines.join('\n') + '\n';
}

/**
 * Update .gitignore to exclude .env files
 *
 * @param projectRoot - Project root directory
 */
async function updateGitignore(projectRoot: string): Promise<void> {
  const gitignorePath = path.join(projectRoot, '.gitignore');

  let content = '';
  if (await fs.pathExists(gitignorePath)) {
    content = await fs.readFile(gitignorePath, 'utf-8');
  }

  // Check if .env patterns already exist
  const hasEnvPattern = /^\.env$/m.test(content);
  const hasEnvLocalPattern = /^\.env\.local$/m.test(content);

  if (!hasEnvPattern || !hasEnvLocalPattern) {
    const lines = content.split('\n');

    // Add SpecWeave section if not exists
    if (!content.includes('# SpecWeave - Environment variables')) {
      lines.push('');
      lines.push('# SpecWeave - Environment variables (contains secrets!)');

      if (!hasEnvPattern) {
        lines.push('.env');
      }

      if (!hasEnvLocalPattern) {
        lines.push('.env.local');
      }
    }

    await fs.writeFile(gitignorePath, lines.join('\n') + '\n', 'utf-8');
  }
}

/**
 * Check if .env file exists
 *
 * @param projectRoot - Project root directory
 * @returns True if .env exists
 */
export async function envFileExists(projectRoot: string): Promise<boolean> {
  const envPath = path.join(projectRoot, '.env');
  return fs.pathExists(envPath);
}

/**
 * Load configuration from .env file
 *
 * @param projectRoot - Project root directory
 * @returns Environment configuration
 */
export async function loadEnvConfig(projectRoot: string): Promise<EnvConfig | null> {
  const envPath = path.join(projectRoot, '.env');

  if (!await fs.pathExists(envPath)) {
    return null;
  }

  const content = await fs.readFile(envPath, 'utf-8');
  const lines = content.split('\n');

  const config: EnvConfig = {};

  for (const line of lines) {
    const trimmed = line.trim();

    if (trimmed.startsWith('#') || !trimmed) {
      continue;
    }

    const [key, value] = trimmed.split('=');

    if (!key || !value) {
      continue;
    }

    switch (key.trim()) {
      case 'GITHUB_TOKEN':
        config.githubToken = value.trim();
        break;
      case 'GITHUB_OWNER':
        config.githubOwner = value.trim();
        break;
      case 'GITHUB_REPOS':
        config.repos = value.trim().split(',').map(mapping => {
          const [id, repo] = mapping.split(':');
          return { id: id.trim(), repo: repo.trim() };
        });
        break;
      case 'GITHUB_SYNC_ENABLED':
        config.syncEnabled = value.trim() === 'true';
        break;
      case 'GITHUB_AUTO_CREATE_ISSUE':
        config.autoCreateIssue = value.trim() === 'true';
        break;
      case 'GITHUB_SYNC_DIRECTION':
        config.syncDirection = value.trim() as any;
        break;
    }
  }

  return config;
}
