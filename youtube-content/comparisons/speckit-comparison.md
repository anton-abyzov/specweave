# SpecKit vs SpecWeave: Detailed Comparison

## Overview

SpecKit and SpecWeave both emphasize specification-driven development, but they differ significantly in scope, features, and use cases. SpecKit is a lightweight toolkit, while SpecWeave is a comprehensive framework.

## What is SpecKit?

**SpecKit** is a minimalist specification management toolkit that provides:

- **Templates** for creating technical specifications
- **Validation** tools to ensure spec completeness
- **Workflows** for spec creation and review
- **Format** standardization across projects

SpecKit focuses solely on **managing specifications** and leaves implementation, testing, and deployment to other tools.

### Key Features

- Spec templates (API specs, feature specs, architecture specs)
- Validation rules (required sections, format checks)
- Spec versioning
- Lightweight CLI
- Format conversion (Markdown, JSON, YAML)

## Side-by-Side Comparison

### 1. Scope

| Aspect | SpecKit | SpecWeave |
|--------|---------|-----------|
| **Primary Focus** | Specification management only | End-to-end development framework |
| **Scope** | Narrow (specs only) | Comprehensive (specs → code → tests → deploy) |
| **AI Integration** | Minimal/external | Deep integration (skills system) |
| **Implementation** | Not included | Integrated (developer skill) |
| **Testing** | Not included | Mandatory (E2E + skill tests) |
| **Documentation** | Specs only | Living docs + auto-updates |

### 2. Features Comparison

| Feature | SpecKit | SpecWeave |
|---------|---------|-----------|
| **Spec Creation** | ✅ Templates | ✅ AI-assisted via spec-author skill |
| **Spec Validation** | ✅ Rules-based | ✅ + Completeness checks |
| **Spec Organization** | ✅ File-based | ✅ Modular with context manifests |
| **Context Loading** | ❌ N/A | ✅ Selective (70%+ reduction) |
| **Feature Planning** | ❌ Not included | ✅ increment-planner skill |
| **Implementation** | ❌ External tools | ✅ developer skill |
| **Testing** | ❌ Not included | ✅ Mandatory E2E + skill tests |
| **Brownfield Support** | ❌ Limited | ✅ brownfield-analyzer skill |
| **Living Documentation** | ❌ Static specs | ✅ Auto-updates via hooks |
| **Skills/Agents** | ❌ None | ✅ Extensible skills system |
| **Integration** | ❌ Manual | ✅ JIRA/GitHub/ADO sync |

### 3. Philosophy

**SpecKit:**
> "Give developers tools to write and manage specifications. Let them choose their own implementation tools."

- **Unopinionated** about implementation
- **Lightweight** by design
- **Flexible** - works with any tech stack, any tools
- **Portable** - specs are just Markdown files

**SpecWeave:**
> "Specifications are the source of truth. The entire development workflow should flow from them."

- **Opinionated** about workflow (spec → plan → implement → test)
- **Comprehensive** framework
- **Integrated** - specs, planning, coding, testing in one system
- **Scalable** - context precision enables enterprise use

### 4. Project Structure

**SpecKit Structure:**
```
project/
├── specs/
│   ├── features/
│   │   ├── auth.md
│   │   └── payments.md
│   ├── api/
│   │   ├── endpoints.md
│   │   └── contracts.md
│   └── architecture/
│       └── system-design.md
├── src/                    # Use your own tools
├── tests/                  # Use your own framework
└── .speckit/
    └── config.yaml
```

**SpecWeave Structure:**
```
project/
├── specifications/
│   └── modules/            # Modular specs
│       ├── authentication/
│       └── payments/
├── .specweave/docs/
│   ├── architecture/       # Living docs (auto-updated)
│   └── decisions/          # ADRs
├── features/
│   └── 001-feature/
│       ├── spec.md
│       ├── plan.md         # Generated by increment-planner
│       ├── tasks.md        # Executable checklist
│       ├── tests.md        # Test strategy
│       └── context-manifest.yaml  # Context precision
├── src/                    # Implemented by developer skill
├── tests/
│   └── e2e/                # Generated by playwright-tester
└── .specweave/
    └── config.yaml
```

### 5. Workflow Comparison

**SpecKit Workflow (Spec Management Only):**
```
1. Create spec from template:
   $ speckit create --template api-spec payment-api

2. Edit spec manually:
   # Edit specs/api/payment-api.md in your editor

3. Validate spec:
   $ speckit validate specs/api/payment-api.md

4. Export spec (optional):
   $ speckit export specs/api/payment-api.md --format json

5. Implement separately:
   # Use your own tools (VS Code, Claude Code, etc.)
   # SpecKit doesn't help here

6. Test separately:
   # Use your own testing framework
   # SpecKit doesn't help here

7. Deploy separately:
   # Use your own deployment tools
   # SpecKit doesn't help here
```

**SpecWeave Workflow (End-to-End):**
```
1. Create spec with AI assistance:
   User: "Create a specification for payment API"
   → spec-author skill creates modular spec

2. Plan feature:
   User: "Plan implementation of payment API"
   → increment-planner creates:
     - spec.md
     - plan.md
     - tasks.md
     - tests.md
     - context-manifest.yaml

3. Implement with context precision:
   User: "Implement payment API feature"
   → context-loader loads only relevant specs (70% reduction)
   → developer skill implements code
   → qa-engineer generates tests

4. Validate automatically:
   → playwright-tester creates E2E tests
   → Tests run automatically
   → Validation report generated

5. Documentation auto-updates:
   → post-task-completion hook fires
   → docs-updater updates API reference
   → Changelog updated

6. Deploy with confidence:
   # All tests pass, docs up-to-date, specs validated
```

### 6. Use Case Examples

#### Use Case 1: Creating a Feature Specification

**SpecKit Approach:**
```bash
# Create from template
$ speckit create --template feature-spec user-authentication

# Manually fill in:
# - Purpose
# - Requirements
# - Acceptance criteria
# - API contracts
# - Data models

# Validate
$ speckit validate specs/features/user-authentication.md

# Output:
# ✅ Required sections present
# ✅ Format valid
# ⚠️  Acceptance criteria could be more specific
```

Result: You have a spec file. Now you implement it yourself.

**SpecWeave Approach:**
```
User: "Create a specification for user authentication with
       email/password, OAuth, and 2FA support."

→ spec-author skill activates:
  - Asks clarifying questions about:
    - Password requirements
    - Session duration
    - OAuth providers
    - 2FA methods
  - Creates modular spec in specifications/modules/authentication/
  - Links to related specs (security, user management)
  - Generates API contracts
  - Creates data models
  - Documents constraints

Result: Complete, AI-assisted spec ready for implementation
```

#### Use Case 2: Implementing a Feature

**SpecKit Approach:**
```
1. Read spec manually
2. Open your IDE (VS Code, etc.)
3. Code feature yourself (or use AI assistant separately)
4. Write tests yourself (or use testing tools separately)
5. Update docs yourself (manual)

SpecKit is not involved - it only managed the spec.
```

**SpecWeave Approach:**
```
User: "Implement user authentication feature"

→ Integrated workflow:
  1. context-loader reads context-manifest.yaml
  2. Loads only relevant specs (8k tokens vs 50k)
  3. developer skill implements:
     - Database schema
     - API routes
     - Services
     - Middleware
     - Frontend components
  4. qa-engineer generates tests:
     - Unit tests
     - Integration tests
  5. playwright-tester creates E2E tests
  6. All tests run
  7. docs-updater updates API reference

Result: Feature implemented, tested, documented - all from one command.
```

#### Use Case 3: Brownfield Project (Existing Codebase)

**SpecKit Approach:**
```
1. Manually review existing code
2. Create specs that describe current behavior:
   $ speckit create --template feature-spec existing-auth
3. Fill in spec manually by reading code
4. Validate spec:
   $ speckit validate specs/existing-auth.md

Result: You have documented the existing system in a spec.
        No assistance with analysis, testing, or safe modification.
```

**SpecWeave Approach:**
```
User: "Analyze the existing authentication system"

→ brownfield-analyzer skill:
  1. Scans src/auth/ automatically
  2. Identifies:
     - Entry points (routes, controllers)
     - Database schema
     - Business logic
     - API endpoints
     - Dependencies
  3. Generates retroactive specs:
     - specifications/modules/authentication/existing/overview.md
     - specifications/modules/authentication/existing/api-contracts.md
     - specifications/modules/authentication/existing/data-model.md
     - specifications/modules/authentication/existing/business-rules.md
     - specifications/modules/authentication/existing/constraints.md
  4. Creates dependency graph
  5. Identifies modification risks

User: "Create regression tests for current auth behavior"

→ playwright-tester skill:
  1. Reads generated specs
  2. Creates comprehensive E2E tests
  3. Tests validate all current behavior

User: "Add OAuth to existing auth system"

→ Safe modification workflow:
  1. pre-implementation hook verifies specs + tests exist
  2. Runs baseline regression tests
  3. context-loader loads existing specs + new feature
  4. developer implements with constraints
  5. Regression tests re-run (must pass)
  6. New OAuth tests validate new functionality

Result: Existing system documented, tested, and safely extended.
```

### 7. Context Management

**SpecKit:**
- No context management (just manages spec files)
- If using with AI assistant, you manually choose which specs to load
- No optimization, no token reduction

**SpecWeave:**
- Context manifests declare exactly what's needed
- Selective loading (70-98% token reduction)
- Scales to enterprise codebases (500+ page specs)

**Example:**

**Project:** E-commerce platform (200 spec files, 500k tokens if loaded fully)

**SpecKit:**
```
# No help from SpecKit - you manually decide what to include
# Pass specs to your AI assistant manually
$ cat specs/payments/stripe.md specs/api/payments.md | pbcopy
# Paste into Claude/GPT

Problem: Easy to miss related specs, hard to optimize
```

**SpecWeave:**
```yaml
# features/042-stripe-integration/context-manifest.yaml
spec_sections:
  - specifications/modules/payments/stripe/spec.md
  - specifications/modules/payments/shared/compliance.md
  - specifications/modules/payments/shared/entities.md

documentation:
  - .specweave/docs/architecture/payment-flow.md

max_context_tokens: 10000

# context-loader automatically loads only these
# AI gets exactly what it needs, nothing more
# 10k tokens vs 500k = 98% reduction
```

### 8. Testing Support

| Aspect | SpecKit | SpecWeave |
|--------|---------|-----------|
| **Unit Tests** | Not included (use your own) | qa-engineer generates |
| **Integration Tests** | Not included | qa-engineer generates |
| **E2E Tests** | Not included | playwright-tester (MANDATORY for UI) |
| **Test Validation** | Not included | Closed-loop validation |
| **Regression Tests** | Not included | Auto-generated for brownfield |
| **Test Reports** | Not included | Validation reports |

### 9. Team Size & Complexity

**SpecKit:**
- **Best for**: Small teams, simple projects
- **Team size**: 1-10 people
- **Codebase**: Small-medium (< 50k lines)
- **Complexity**: Low-medium
- **Flexibility**: Maximum (choose your own everything)

**SpecWeave:**
- **Best for**: Solo to enterprise, any complexity
- **Team size**: 1-1000+ people
- **Codebase**: Any size (context manifests scale)
- **Complexity**: Low to very high (brownfield-ready)
- **Flexibility**: Opinionated workflow, but customizable (skills)

### 10. Learning Curve

**SpecKit:**
- ⭐ **Very Easy**
- Install CLI
- Learn template format
- Use validation commands
- Total time: 1-2 hours

**SpecWeave:**
- ⭐⭐⭐ **Moderate**
- Understand specification philosophy
- Learn directory structure
- Understand context manifests
- Learn skills system
- Total time: 1-2 days

### 11. Cost & Performance

**SpecKit:**
- No AI token usage (static tool)
- Lightweight (< 10MB)
- Fast (simple file operations)
- Free and open-source

**SpecWeave:**
- AI token usage (but 70%+ reduction via manifests)
- Moderate weight (~100MB with skills)
- Performance depends on AI backend
- Free and open-source

### 12. Integration & Extensibility

**SpecKit:**
- **Integration**: Minimal (export specs to JSON/YAML for other tools)
- **Extensibility**: Custom templates
- **Ecosystem**: Bring your own tools

**SpecWeave:**
- **Integration**: Rich (JIRA, GitHub, ADO via MCP)
- **Extensibility**: Custom skills (add domain expertise)
- **Ecosystem**: Integrated (specs → code → tests → docs)

## When to Choose Each

### Choose SpecKit if:

✅ You only need specification management
✅ You want maximum flexibility (choose your own implementation tools)
✅ You prefer lightweight, simple tools
✅ You have small projects (< 50k lines)
✅ You're not using AI assistants heavily
✅ You want minimal learning curve
✅ You like Unix philosophy (do one thing well)
✅ Your team already has established implementation workflows

**Ideal for:**
- Documenting small projects
- Creating portable specs (share across tools)
- Teams who want spec templates only
- Developers who prefer manual control

### Choose SpecWeave if:

✅ You want end-to-end AI-assisted development
✅ You need context precision (large codebases)
✅ You're working on brownfield projects (legacy code)
✅ You want integrated workflow (spec → code → test)
✅ You need living documentation (auto-updates)
✅ You want test-validated features (E2E mandatory)
✅ You're scaling from solo to enterprise
✅ You need regression prevention
✅ You want custom AI skills for your domain

**Ideal for:**
- End-to-end AI-assisted development
- Large codebases (enterprise scale)
- Brownfield transformation
- Teams wanting integrated workflow
- Context-constrained environments

## Can You Use Both?

**Yes!** SpecKit and SpecWeave can complement each other:

**Scenario 1: Start with SpecKit, Graduate to SpecWeave**
```
1. Use SpecKit to create initial specs (lightweight start)
2. As project grows, migrate to SpecWeave for:
   - Context precision
   - Integrated implementation
   - Automated testing
   - Brownfield support
```

**Scenario 2: SpecKit for Portable Specs, SpecWeave for Implementation**
```
1. Use SpecKit to create portable specification format
2. Export SpecKit specs to SpecWeave format
3. Use SpecWeave for implementation, testing, deployment
4. SpecKit specs remain as interchange format
```

**Migration Path:**
```bash
# Export SpecKit specs
$ speckit export specs/ --format specweave --output specifications/

# Result: SpecWeave-compatible modular specs
specifications/
  └── modules/
      ├── authentication/
      └── payments/

# Now use SpecWeave for implementation
$ specweave init --brownfield  # If migrating existing project
```

## Detailed Example: Building a Payment System

### With SpecKit

**Step 1: Create Spec**
```bash
$ speckit create --template api-spec payment-processing
# Creates specs/payment-processing.md

# Edit manually:
# API Specification: Payment Processing
#
# ## Endpoints
# POST /api/payments
# GET /api/payments/:id
# ...
#
# ## Data Models
# Payment:
#   - id: string
#   - amount: number
#   ...
```

**Step 2: Validate**
```bash
$ speckit validate specs/payment-processing.md
✅ Valid specification
```

**Step 3: Implementation (Outside SpecKit)**
```bash
# Open your IDE
# Read the spec
# Implement yourself or use AI assistant separately
# SpecKit is done - no further help
```

**Total SpecKit involvement**: Creating and validating spec file

---

### With SpecWeave

**Step 1: Create Spec with AI**
```
User: "Create specification for payment processing with
       Stripe integration, including subscriptions and refunds."

→ spec-author skill:
  - Creates specifications/modules/payments/stripe/
    - spec.md (complete spec with API contracts)
    - data-model.md (database schema)
    - compliance.md (PCI-DSS requirements)
  - Links to shared payment entities
  - Includes acceptance criteria
  - Documents constraints
```

**Step 2: Plan Implementation**
```
User: "Plan implementation of payment processing feature"

→ increment-planner skill:
  - Creates features/023-stripe-integration/
    - spec.md (feature spec)
    - plan.md (implementation phases)
    - tasks.md (executable checklist)
    - tests.md (test strategy)
    - context-manifest.yaml (only 8k tokens needed)
```

**Step 3: Implement with Context Precision**
```
User: "Implement Stripe integration feature"

→ Automated workflow:
  1. context-loader loads only relevant specs (8k tokens)
  2. developer skill implements:
     - Database migration
     - Stripe client
     - Payment service
     - API routes
     - Frontend components
  3. qa-engineer generates tests
  4. playwright-tester creates E2E tests
```

**Step 4: Validate**
```
→ Automatic validation:
  - Unit tests run
  - Integration tests run
  - E2E tests validate actual payment flow
  - Validation report generated
```

**Step 5: Documentation Auto-Update**
```
→ post-task-completion hook:
  - docs-updater updates API reference
  - Changelog updated
  - Architecture docs updated
```

**Total SpecWeave involvement**: End-to-end (spec → code → tests → docs)

## Summary

### SpecKit: Lightweight Spec Management
- 🎯 **Focus**: Specifications only
- 📦 **Scope**: Narrow (one tool, one job)
- 🪶 **Weight**: Very lightweight
- 🛠️ **Flexibility**: Maximum (choose your own tools)
- 📚 **Learning**: Easy (1-2 hours)
- 👥 **Best For**: Small teams, simple projects, portable specs

### SpecWeave: Comprehensive Development Framework
- 🎯 **Focus**: End-to-end development (spec → deploy)
- 📦 **Scope**: Comprehensive (integrated workflow)
- 🏗️ **Weight**: Moderate (full framework)
- 🛠️ **Flexibility**: Opinionated but extensible (skills)
- 📚 **Learning**: Moderate (1-2 days)
- 👥 **Best For**: Solo to enterprise, brownfield, large codebases

## Recommendation

**For Spec Management Only:**
→ **SpecKit** (lightweight, simple, flexible)

**For Full Development Workflow:**
→ **SpecWeave** (integrated, AI-assisted, test-validated)

**For Enterprise/Brownfield:**
→ **SpecWeave** (context precision + brownfield-analyzer are critical)

**For Small Projects:**
→ **SpecKit** if you want simplicity
→ **SpecWeave** if you want AI assistance

**Want Both?**
→ Start with SpecKit, migrate to SpecWeave as project grows
→ Or use SpecKit for portable specs + SpecWeave for implementation

---

**Last Updated**: 2025-01-26
**Related**: [BMAD Comparison](bmad-comparison.md)
