/**
 * End-to-End Integration Tests for Self-Reflection System
 *
 * Tests the complete workflow:
 * 1. Configuration loading
 * 2. Git diff analysis
 * 3. Prompt building
 * 4. Response parsing
 * 5. Storage
 */

import fs from 'fs-extra';
import path from 'path';
import * as os from 'os';
import { execSync } from 'child_process';
import { createReflectionContext } from '../../plugins/specweave/lib/hooks/run-self-reflection.js';
import { buildReflectionPrompt } from '../../plugins/specweave/lib/hooks/reflection-prompt-builder.js';
import { parseReflectionMarkdown } from '../../plugins/specweave/lib/hooks/reflection-parser.js';
import { saveReflection, listReflections, readReflection } from '../../plugins/specweave/lib/hooks/reflection-storage.js';
import {
  prepareReflectionContext,
  hasReflectionContext,
  readReflectionContext,
  clearReflectionContext
} from '../../plugins/specweave/lib/hooks/prepare-reflection-context.js';
import { ReflectionModel } from '../../plugins/specweave/lib/hooks/types/reflection-types.js';

describe('Self-Reflection System - End-to-End', () => {
  // âœ… SAFE: Isolated test directory (prevents .specweave deletion)
  const testDir = path.join(os.tmpdir(), 'specweave-test-reflection-' + Date.now());
  const incrementId = '0016-self-reflection-system';
  const taskId = 'T-005';

  // Sample agent response for testing
  const mockAgentResponse = `
# Self-Reflection: Task T-005 - Implement Reflection Engine

**Completed**: 2025-11-10T14:30:00Z
**Duration**: 45 minutes
**Files Modified**: 3 files, +287 -45

---

## âœ… What Was Accomplished

- Created run-self-reflection.ts with agent invocation logic
- Added configuration loading from .specweave/config.json
- Implemented reflection prompt builder

---

## ðŸŽ¯ Quality Assessment

### âœ… Strengths

- âœ… Clean separation of concerns (engine vs agent)
- âœ… Type-safe configuration loading

### âš ï¸ Issues Identified

**CRITICAL (SECURITY)**
- âŒ API key exposed in debug logs
  - **Impact**: Potential credential leakage
  - **Recommendation**: Redact API keys before logging
  - **Location**: \`src/hooks/lib/run-self-reflection.ts:45\`

---

## ðŸ”§ Recommended Follow-Up Actions

**Priority 1 (MUST FIX)**:
1. Redact API keys in debug logging

**Priority 2 (SHOULD FIX)**:
1. Add error handling tests

**Priority 3 (NICE TO HAVE)**:
1. Add performance metrics tracking

---

## ðŸ“š Lessons Learned

**What went well**:
- TypeScript types caught configuration errors early

**What could improve**:
- Should have added API failure tests from start

**For next time**:
- Always review security implications before implementing

---

## ðŸ“Š Metrics

- **Code Quality**: 7/10
- **Security**: 6/10
- **Test Coverage**: 85%
- **Technical Debt**: MEDIUM
- **Performance**: GOOD

---

**Auto-generated by**: SpecWeave Self-Reflection System
**Model**: Claude 3.5 Haiku
**Reflection Time**: 23 seconds
**Estimated Cost**: ~$0.008
`;

  beforeAll(() => {
    // Clean up test directory
    if (fs.existsSync(testDir)) {
      fs.removeSync(testDir);
    }
    fs.mkdirpSync(testDir);

    // Create .specweave structure
    const specweaveDir = path.join(testDir, '.specweave');
    fs.mkdirpSync(specweaveDir);

    // Create config.json
    fs.writeJsonSync(path.join(specweaveDir, 'config.json'), {
      reflection: {
        enabled: true,
        mode: 'auto',
        depth: 'standard',
        model: 'haiku'
      }
    });

    // Create increment structure
    const incrementDir = path.join(specweaveDir, 'increments', incrementId);
    fs.mkdirpSync(incrementDir);

    // Initialize git repository
    execSync('git init', { cwd: testDir });
    execSync('git config user.name "Test User"', { cwd: testDir });
    execSync('git config user.email "test@example.com"', { cwd: testDir });

    // Create initial commit
    fs.writeFileSync(path.join(testDir, 'test-file.ts'), 'const x = 1;\n');
    execSync('git add .', { cwd: testDir });
    execSync('git commit -m "Initial commit"', { cwd: testDir });

    // Modify file to create diff
    fs.appendFileSync(path.join(testDir, 'test-file.ts'), 'const y = 2;\n');
  });

  afterAll(() => {
    // Clean up test directory
    if (fs.existsSync(testDir)) {
      fs.removeSync(testDir);
    }
  });

  describe('Complete Workflow', () => {
    it('should execute complete reflection workflow', () => {
      // Step 1: Create reflection context
      const context = createReflectionContext(incrementId, taskId, testDir);

      expect(context.incrementId).toBe(incrementId);
      expect(context.taskId).toBe(taskId);
      expect(context.config).toBeDefined();
      expect(context.config.enabled).toBe(true);
      expect(context.modifiedFiles.length).toBeGreaterThan(0);

      // Step 2: Build reflection prompt
      const prompt = buildReflectionPrompt({
        taskId: context.taskId,
        taskName: 'Implement Reflection Engine',
        modifiedFiles: context.modifiedFiles,
        config: context.config,
        incrementId: context.incrementId
      });

      expect(prompt).toContain('# Self-Reflection Request');
      expect(prompt).toContain(taskId);
      expect(prompt).toContain('test-file.ts');

      // Step 3: Parse agent response (simulated)
      const result = parseReflectionMarkdown(
        mockAgentResponse,
        'T-005: Implement Reflection Engine',
        ReflectionModel.HAIKU,
        23,
        0.008
      );

      expect(result.taskName).toBe('T-005: Implement Reflection Engine');
      expect(result.accomplishments.length).toBeGreaterThan(0);
      expect(result.issues.length).toBeGreaterThan(0);

      // Step 4: Save reflection
      const savedPath = saveReflection(result, incrementId, taskId, testDir);

      expect(fs.existsSync(savedPath)).toBe(true);

      // Step 5: List reflections
      const reflections = listReflections(incrementId, testDir);

      expect(reflections.length).toBe(1);
      expect(reflections[0]).toBe(savedPath);

      // Step 6: Read reflection
      const savedContent = readReflection(savedPath);

      expect(savedContent).toContain('# Self-Reflection');
      expect(savedContent).toContain('API key exposed');
      expect(savedContent).toContain('**Code Quality**: 7/10');
    });
  });

  describe('Context Preparation (Hook Integration)', () => {
    it('should prepare reflection context for hook', () => {
      const contextFile = prepareReflectionContext(incrementId, taskId, testDir);

      expect(contextFile).not.toBeNull();
      expect(fs.existsSync(contextFile!)).toBe(true);

      const contextData = readReflectionContext(incrementId, testDir);

      expect(contextData).not.toBeNull();
      expect(contextData.incrementId).toBe(incrementId);
      expect(contextData.taskId).toBe(taskId);
      expect(contextData.modifiedFiles).toBeDefined();
      expect(contextData.fileSummary).toBeDefined();
    });

    it('should detect existing reflection context', () => {
      prepareReflectionContext(incrementId, taskId, testDir);

      expect(hasReflectionContext(incrementId, testDir)).toBe(true);
    });

    it('should clear reflection context', () => {
      prepareReflectionContext(incrementId, taskId, testDir);

      expect(hasReflectionContext(incrementId, testDir)).toBe(true);

      clearReflectionContext(incrementId, testDir);

      expect(hasReflectionContext(incrementId, testDir)).toBe(false);
    });

    it('should return null when reflection disabled', () => {
      // Update config to disable reflection
      const configPath = path.join(testDir, '.specweave', 'config.json');
      fs.writeJsonSync(configPath, {
        reflection: {
          enabled: false
        }
      });

      const contextFile = prepareReflectionContext(incrementId, taskId, testDir);

      expect(contextFile).toBeNull();

      // Restore config
      fs.writeJsonSync(configPath, {
        reflection: {
          enabled: true,
          mode: 'auto',
          depth: 'standard',
          model: 'haiku'
        }
      });
    });
  });

  describe('Error Handling', () => {
    it('should handle missing git repository gracefully', () => {
      const nonGitDir = path.join(testDir, 'non-git');
      fs.mkdirpSync(nonGitDir);

      const context = createReflectionContext(incrementId, taskId, nonGitDir);

      expect(context.modifiedFiles.length).toBe(0);
    });

    it('should handle missing config file gracefully', () => {
      const noConfigDir = path.join(testDir, 'no-config');
      fs.mkdirpSync(noConfigDir);
      fs.mkdirpSync(path.join(noConfigDir, '.specweave'));

      const context = createReflectionContext(incrementId, taskId, noConfigDir);

      // Should use default config
      expect(context.config.enabled).toBe(true);
      expect(context.config.mode).toBe('auto');
    });

    it('should handle storage errors gracefully', () => {
      const readOnlyDir = path.join(testDir, '.specweave', 'increments', incrementId, 'logs', 'reflections');
      fs.mkdirpSync(readOnlyDir);
      fs.chmodSync(readOnlyDir, 0o444); // Read-only

      const result = parseReflectionMarkdown(mockAgentResponse, 'Test Task');

      expect(() => {
        saveReflection(result, incrementId, taskId, testDir);
      }).toThrow();

      // Restore permissions for cleanup
      fs.chmodSync(readOnlyDir, 0o755);
    });
  });

  describe('Data Integrity', () => {
    it('should preserve all reflection data through save/load cycle', () => {
      const originalResult = parseReflectionMarkdown(
        mockAgentResponse,
        'T-005: Implement Reflection Engine',
        ReflectionModel.HAIKU,
        23,
        0.008
      );

      const savedPath = saveReflection(originalResult, incrementId, 'T-999', testDir);
      const savedMarkdown = readReflection(savedPath);
      const reparsedResult = parseReflectionMarkdown(savedMarkdown, 'Test Task');

      // Verify key data is preserved
      expect(reparsedResult.accomplishments.length).toBe(originalResult.accomplishments.length);
      expect(reparsedResult.strengths.length).toBe(originalResult.strengths.length);
      expect(reparsedResult.issues.length).toBe(originalResult.issues.length);
      expect(reparsedResult.metrics.codeQuality).toBe(originalResult.metrics.codeQuality);
    });

    it('should maintain issue details after save/load', () => {
      const originalResult = parseReflectionMarkdown(mockAgentResponse, 'Test Task');

      const savedPath = saveReflection(originalResult, incrementId, 'T-998', testDir);
      const savedMarkdown = readReflection(savedPath);
      const reparsedResult = parseReflectionMarkdown(savedMarkdown, 'Test Task');

      const originalIssue = originalResult.issues[0];
      const reparsedIssue = reparsedResult.issues[0];

      expect(reparsedIssue.severity).toBe(originalIssue.severity);
      expect(reparsedIssue.category).toBe(originalIssue.category);
      expect(reparsedIssue.description).toContain('API key');
      expect(reparsedIssue.location?.file).toContain('run-self-reflection.ts');
    });
  });

  describe('Performance', () => {
    it('should handle large file sets efficiently', () => {
      // Create multiple files
      for (let i = 0; i < 10; i++) {
        fs.writeFileSync(path.join(testDir, `file${i}.ts`), `const x${i} = ${i};\n`);
      }
      execSync('git add .', { cwd: testDir });

      const startTime = Date.now();
      const context = createReflectionContext(incrementId, taskId, testDir);
      const endTime = Date.now();

      expect(context.modifiedFiles.length).toBeGreaterThan(0);
      expect(endTime - startTime).toBeLessThan(2000); // Should complete in < 2s
    });

    it('should build prompt quickly', () => {
      const context = createReflectionContext(incrementId, taskId, testDir);

      const startTime = Date.now();
      buildReflectionPrompt({
        taskId: context.taskId,
        modifiedFiles: context.modifiedFiles,
        config: context.config,
        incrementId: context.incrementId
      });
      const endTime = Date.now();

      expect(endTime - startTime).toBeLessThan(100); // Should be very fast
    });
  });
});
