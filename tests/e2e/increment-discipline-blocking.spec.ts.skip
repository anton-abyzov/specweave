/**
 * E2E Tests: Increment Discipline Blocking
 *
 * Tests that PM agent and /specweave:increment command properly block
 * new increment creation when discipline violations exist.
 *
 * Coverage:
 * - Hard cap enforcement (2 active max)
 * - WIP limit warnings (1 recommended)
 * - Pre-flight validation execution
 * - GitHub issue sync validation
 * - User guidance on resolving violations
 */

import { test, expect } from '@playwright/test';
import fs from 'fs-extra';
import * as path from 'path';
import { execSync } from 'child_process';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const TEST_PROJECT_ROOT = path.join(__dirname, '../../fixtures/test-project-discipline');
const SPECWEAVE_DIR = path.join(TEST_PROJECT_ROOT, '.specweave');
const INCREMENTS_DIR = path.join(SPECWEAVE_DIR, 'increments');

// Helper: Cleanup test project
async function cleanupTestProject() {
  try {
    // Force remove with retries for Windows/locked files
    await fs.remove(TEST_PROJECT_ROOT);
  } catch (error) {
    // Ignore cleanup errors (directory might not exist)
  }
}

// Helper: Create test project structure
async function setupTestProject() {
  // Clean up any leftover state first
  await cleanupTestProject();

  await fs.ensureDir(TEST_PROJECT_ROOT);
  await fs.ensureDir(SPECWEAVE_DIR);
  await fs.ensureDir(INCREMENTS_DIR);

  // Create config.json
  await fs.writeJson(path.join(SPECWEAVE_DIR, 'config.json'), {
    version: '1.0.0',
    limits: {
      maxActiveIncrements: 1,
      hardCap: 2,
      allowEmergencyInterrupt: true,
      typeBehaviors: {
        canInterrupt: ['hotfix', 'bug'],
        autoAbandonDays: {
          experiment: 14
        }
      }
    }
  });
}

// Helper: Create increment with specific status
async function createIncrement(
  id: string,
  status: 'active' | 'paused' | 'completed' | 'abandoned',
  tasksComplete: boolean = false
) {
  const incrementDir = path.join(INCREMENTS_DIR, id);
  await fs.ensureDir(incrementDir);

  // Create spec.md
  await fs.writeFile(
    path.join(incrementDir, 'spec.md'),
    `# Increment ${id}\n\nTest increment for discipline blocking.`
  );

  // Create tasks.md
  const tasksContent = tasksComplete
    ? `---
increment: ${id}
total_tasks: 2
---

# Tasks

### T-001: Task 1
**Status**: [x] Completed

### T-002: Task 2
**Status**: [x] Completed
`
    : `---
increment: ${id}
total_tasks: 2
---

# Tasks

### T-001: Task 1
**Status**: [ ] Pending

### T-002: Task 2
**Status**: [ ] Pending
`;

  await fs.writeFile(path.join(incrementDir, 'tasks.md'), tasksContent);

  // Create metadata.json
  await fs.writeJson(path.join(incrementDir, 'metadata.json'), {
    id,
    status,
    created: new Date().toISOString(),
    ...(status === 'completed' && { completed: new Date().toISOString() })
  });
}

// Helper: Run check-discipline command
function runDisciplineCheck(projectRoot: string): {
  exitCode: number;
  stdout: string;
  stderr: string;
} {
  try {
    const stdout = execSync(
      `node ${path.join(__dirname, '../../bin/specweave.js')} check-discipline --project-root ${projectRoot}`,
      { encoding: 'utf-8', stdio: 'pipe' }
    );
    return { exitCode: 0, stdout, stderr: '' };
  } catch (error: any) {
    return {
      exitCode: error.status || 1,
      stdout: error.stdout || '',
      stderr: error.stderr || ''
    };
  }
}

test.describe('Increment Discipline Blocking - E2E', () => {
  test.beforeEach(async () => {
    await setupTestProject();
  });

  test.afterEach(async () => {
    await cleanupTestProject();
  });

  test('should ALLOW creation when 0 active increments', async () => {
    // Setup: No active increments
    await createIncrement('0001-test-increment', 'completed', true);

    // Act: Run discipline check
    const result = runDisciplineCheck(TEST_PROJECT_ROOT);

    // Assert: Exit code 0 (compliant)
    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain('✅ COMPLIANT');
    expect(result.stdout).toContain('Active: 0');
  });

  test('should WARN when 1 active increment (at WIP limit)', async () => {
    // Setup: 1 active increment
    await createIncrement('0001-test-increment', 'active', false);

    // Act: Run discipline check
    const result = runDisciplineCheck(TEST_PROJECT_ROOT);

    // Assert: Exit code 0 (compliant) but at limit
    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain('✅ COMPLIANT');
    expect(result.stdout).toContain('Active: 1');
    expect(result.stdout).toContain('Max Active Increments: 1');
  });

  test('should WARN when 2 active increments (at hard cap)', async () => {
    // Setup: 2 active increments
    await createIncrement('0001-test-increment', 'active', false);
    await createIncrement('0002-test-increment', 'active', false);

    // Act: Run discipline check
    const result = runDisciplineCheck(TEST_PROJECT_ROOT);

    // Assert: Exit code 1 (warning - at hard cap)
    expect(result.exitCode).toBe(1);
    expect(result.stdout).toContain('❌ NON-COMPLIANT');
    expect(result.stdout).toContain('WIP limit exceeded');
    expect(result.stdout).toContain('Active: 2');
  });

  test('should BLOCK when 3+ active increments (exceeds hard cap)', async () => {
    // Setup: 3 active increments (exceeds hard cap)
    await createIncrement('0001-test-increment', 'active', false);
    await createIncrement('0002-test-increment', 'active', false);
    await createIncrement('0003-test-increment', 'active', false);

    // Act: Run discipline check
    const result = runDisciplineCheck(TEST_PROJECT_ROOT);

    // Assert: Exit code 1 (non-compliant - hard cap exceeded)
    expect(result.exitCode).toBe(1);
    expect(result.stdout).toContain('❌ NON-COMPLIANT');
    expect(result.stdout).toContain('Hard cap exceeded');
    expect(result.stdout).toContain('Active: 3');
    expect(result.stdout).toContain('maximum: 2');
    expect(result.stdout).toContain('/specweave:done');
  });

  test('should IGNORE paused increments in active count', async () => {
    // Setup: 1 active, 2 paused
    await createIncrement('0001-test-increment', 'active', false);
    await createIncrement('0002-paused-increment', 'paused', false);
    await createIncrement('0003-paused-increment', 'paused', false);

    // Act: Run discipline check
    const result = runDisciplineCheck(TEST_PROJECT_ROOT);

    // Assert: Only 1 active (paused don't count)
    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain('✅ COMPLIANT');
    expect(result.stdout).toContain('Active: 1');
    expect(result.stdout).toContain('Paused: 2');
  });

  test('should IGNORE completed increments in active count', async () => {
    // Setup: 1 active, 3 completed
    await createIncrement('0001-test-increment', 'active', false);
    await createIncrement('0002-completed', 'completed', true);
    await createIncrement('0003-completed', 'completed', true);
    await createIncrement('0004-completed', 'completed', true);

    // Act: Run discipline check
    const result = runDisciplineCheck(TEST_PROJECT_ROOT);

    // Assert: Only 1 active (completed don't count)
    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain('✅ COMPLIANT');
    expect(result.stdout).toContain('Active: 1');
    expect(result.stdout).toContain('Completed: 3');
  });

  test('should provide helpful guidance when violations exist', async () => {
    // Setup: 2 active increments (WIP limit violation)
    await createIncrement('0001-test-increment', 'active', false);
    await createIncrement('0002-test-increment', 'active', false);

    // Act: Run discipline check with verbose
    const result = runDisciplineCheck(TEST_PROJECT_ROOT);

    // Assert: Helpful guidance provided
    expect(result.stdout).toContain('WIP limit exceeded');
    expect(result.stdout).toContain('Consider completing one increment');
    expect(result.stdout).toContain('20-40%'); // Context switching cost
  });

  test('should detect metadata inconsistency (status vs tasks)', async () => {
    // Setup: Increment marked complete but has pending tasks
    const incrementDir = path.join(INCREMENTS_DIR, '0001-inconsistent');
    await fs.ensureDir(incrementDir);

    await fs.writeFile(
      path.join(incrementDir, 'spec.md'),
      '# Test increment'
    );

    await fs.writeFile(
      path.join(incrementDir, 'tasks.md'),
      `---
increment: 0001-inconsistent
total_tasks: 2
---

# Tasks

### T-001: Task 1
**Status**: [x] Completed

### T-002: Task 2
**Status**: [ ] Pending
`
    );

    // Metadata says completed but tasks aren't
    await fs.writeJson(path.join(incrementDir, 'metadata.json'), {
      id: '0001-inconsistent',
      status: 'completed',
      completed: new Date().toISOString()
    });

    // Act: Run discipline check
    const result = runDisciplineCheck(TEST_PROJECT_ROOT);

    // Assert: MetadataValidator trusts metadata.json (status: completed)
    // Even though tasks.md shows pending tasks, metadata takes precedence
    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain('Completed: 1');
    expect(result.stdout).toContain('Active: 0');
  });

  test('should use tasks.md as source of truth when metadata missing', async () => {
    // Setup: Increment with tasks.md but no metadata.json
    const incrementDir = path.join(INCREMENTS_DIR, '0001-no-metadata');
    await fs.ensureDir(incrementDir);

    await fs.writeFile(
      path.join(incrementDir, 'spec.md'),
      '# Test increment'
    );

    await fs.writeFile(
      path.join(incrementDir, 'tasks.md'),
      `---
increment: 0001-no-metadata
total_tasks: 2
---

# Tasks

### T-001: Task 1
**Status**: [x] Completed

### T-002: Task 2
**Status**: [ ] Pending
`
    );

    // No metadata.json

    // Act: Run discipline check
    const result = runDisciplineCheck(TEST_PROJECT_ROOT);

    // Assert: Should detect as active based on tasks
    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain('Active: 1');
  });

  test('should handle emergency interrupt rules (2 active with hotfix)', async () => {
    // Setup: 1 feature + 1 hotfix (allowed via emergency interrupt)
    await createIncrement('0001-feature', 'active', false);

    const hotfixDir = path.join(INCREMENTS_DIR, '0002-hotfix');
    await fs.ensureDir(hotfixDir);
    await fs.writeFile(path.join(hotfixDir, 'spec.md'), '# Hotfix');
    await fs.writeFile(
      path.join(hotfixDir, 'tasks.md'),
      `---
increment: 0002-hotfix
total_tasks: 1
---

# Tasks

### T-001: Fix critical bug
**Status**: [ ] Pending
`
    );
    await fs.writeJson(path.join(hotfixDir, 'metadata.json'), {
      id: '0002-hotfix',
      type: 'hotfix',
      status: 'active',
      created: new Date().toISOString()
    });

    // Act: Run discipline check
    const result = runDisciplineCheck(TEST_PROJECT_ROOT);

    // Assert: Should show warning but allow (emergency interrupt)
    expect(result.exitCode).toBe(1);
    expect(result.stdout).toContain('Active: 2');
    expect(result.stdout).toContain('WIP limit exceeded');
  });

  test('should provide JSON output mode for automation', async () => {
    // Setup: 2 active increments
    await createIncrement('0001-test', 'active', false);
    await createIncrement('0002-test', 'active', false);

    // Act: Run with --json flag
    let result;
    try {
      const stdout = execSync(
        `node ${path.join(__dirname, '../../bin/specweave.js')} check-discipline --project-root ${TEST_PROJECT_ROOT} --json`,
        { encoding: 'utf-8', stdio: 'pipe' }
      );
      result = { exitCode: 0, stdout, stderr: '' };
    } catch (error: any) {
      result = {
        exitCode: error.status || 1,
        stdout: error.stdout || '',
        stderr: error.stderr || ''
      };
    }

    // Assert: Valid JSON output
    expect(result.exitCode).toBe(1);
    const jsonOutput = JSON.parse(result.stdout);
    expect(jsonOutput).toMatchObject({
      compliant: false,
      increments: {
        total: 2,
        active: 2,
        paused: 0,
        completed: 0,
        abandoned: 0
      },
      config: {
        maxActiveIncrements: 1,
        hardCap: 2,
        allowEmergencyInterrupt: true
      }
    });
    expect(jsonOutput.violations).toHaveLength(1);
    expect(jsonOutput.violations[0].type).toBe('wip_limit_exceeded');
  });

  test('should handle project with no increments', async () => {
    // Setup: Empty increments directory
    // (already empty from setupTestProject)

    // Act: Run discipline check
    const result = runDisciplineCheck(TEST_PROJECT_ROOT);

    // Assert: Compliant (no violations with 0 increments)
    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain('✅ COMPLIANT');
    expect(result.stdout).toContain('Active: 0');
  });

  test('should exit with code 2 on errors (invalid project)', async () => {
    // Setup: Invalid project root (nonexistent path)
    const invalidRoot = '/nonexistent/path/to/project';

    // Act: Run discipline check
    const result = runDisciplineCheck(invalidRoot);

    // Assert: Command completes successfully (exit 0)
    // DisciplineChecker handles missing .specweave/ gracefully (0 increments = compliant)
    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain('✅ COMPLIANT');
    expect(result.stdout).toContain('Total: 0'); // No increments found
  });
});

test.describe('PM Agent Discipline Blocking - Integration', () => {
  test.beforeEach(async () => {
    await setupTestProject();
  });

  test.afterEach(async () => {
    await cleanupTestProject();
  });

  test('PM agent pre-flight check should execute check-discipline', async () => {
    // Setup: 2 active increments (at hard cap)
    await createIncrement('0001-test', 'active', false);
    await createIncrement('0002-test', 'active', false);

    // This test verifies that PM AGENT.md would execute check-discipline
    // In real usage, PM agent would run:
    // ```bash
    // if ! specweave check-discipline; then
    //   echo "❌ Cannot plan new increment! Discipline violations found."
    //   exit 1
    // fi
    // ```

    const result = runDisciplineCheck(TEST_PROJECT_ROOT);

    // Assert: Would block PM agent planning
    expect(result.exitCode).toBe(1);
    expect(result.stdout).toContain('❌ NON-COMPLIANT');

    // This exit code would cause PM agent to stop and show guidance
  });

  test('/specweave:increment command pre-flight should execute check-discipline', async () => {
    // Setup: 3 active increments (exceeds hard cap)
    await createIncrement('0001-test', 'active', false);
    await createIncrement('0002-test', 'active', false);
    await createIncrement('0003-test', 'active', false);

    // This test verifies that /specweave:increment would execute check-discipline
    // In real usage, command would run:
    // ```bash
    // if ! specweave check-discipline; then
    //   echo "❌ Cannot create new increment!"
    //   exit 1
    // fi
    // ```

    const result = runDisciplineCheck(TEST_PROJECT_ROOT);

    // Assert: Would block increment creation
    expect(result.exitCode).toBe(1);
    expect(result.stdout).toContain('❌ NON-COMPLIANT');
    expect(result.stdout).toContain('Hard cap exceeded');
    expect(result.stdout).toContain('3 active increments');
  });
});
