/**
 * E2E Smoke Test for Self-Reflection System
 *
 * Tests the complete workflow from git changes to reflection storage
 */

import { test, expect } from '@playwright/test';
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';
import { execSync } from 'child_process';
import { createReflectionContext } from '../../../src/hooks/lib/run-self-reflection';
import { buildReflectionPrompt } from '../../../src/hooks/lib/reflection-prompt-builder';
import { parseReflectionMarkdown } from '../../../src/hooks/lib/reflection-parser';
import { saveReflection, listReflections, readReflection } from '../../../src/hooks/lib/reflection-storage';
import { prepareReflectionContext, hasReflectionContext, readReflectionContext, clearReflectionContext } from '../../../src/hooks/lib/prepare-reflection-context';
import { ReflectionModel } from '../../../src/hooks/lib/types/reflection-types';

// ESM compatibility: Get __dirname equivalent
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

test.describe('Self-Reflection System - Smoke Test', () => {
  let testDir: string;
  const incrementId = '0099-smoke-test';
  const taskId = 'T-001';

  // Sample reflection output (simulating agent response)
  const mockAgentResponse = `
# Self-Reflection: Task T-001 - Add User Authentication

**Completed**: 2025-11-10T10:30:00Z
**Duration**: 30 minutes
**Files Modified**: 2 files, +150 -20

---

## âœ… What Was Accomplished

- Implemented JWT-based authentication
- Added password hashing with bcrypt
- Created login endpoint with rate limiting

---

## ğŸ¯ Quality Assessment

### âœ… Strengths

- âœ… Secure password storage (bcrypt with salt rounds = 12)
- âœ… Token expiration configured (15 minutes for access token)
- âœ… Rate limiting prevents brute force attacks (max 5 attempts)

### âš ï¸ Issues Identified

**HIGH (SECURITY)**
- âŒ JWT secret stored in plaintext in config file
  - **Impact**: Secret could be exposed if config file is committed to git
  - **Recommendation**: Move JWT secret to environment variable (.env file)
  - **Location**: \`src/config/auth.ts:12\`

**MEDIUM (QUALITY)**
- âš ï¸ No input validation for email format
  - **Impact**: Malformed emails could cause database errors
  - **Recommendation**: Add email validation regex before database query
  - **Location**: \`src/controllers/auth.ts:45\`

---

## ğŸ”§ Recommended Follow-Up Actions

**Priority 1 (MUST FIX)**:
1. Move JWT secret to environment variable
2. Add .env to .gitignore

**Priority 2 (SHOULD FIX)**:
1. Add email format validation
2. Add unit tests for invalid email scenarios

**Priority 3 (NICE TO HAVE)**:
1. Add logging for failed login attempts
2. Implement account lockout after repeated failures

---

## ğŸ“š Lessons Learned

**What went well**:
- bcrypt integration was straightforward
- Rate limiting library worked as expected

**What could improve**:
- Should have reviewed security checklist before implementation
- Missed email validation during initial design

**For next time**:
- Run security checklist before starting security-critical features
- Add input validation tests from the beginning

---

## ğŸ“Š Metrics

- **Code Quality**: 8/10
- **Security**: 6/10 (JWT secret issue)
- **Test Coverage**: 75%
- **Technical Debt**: LOW
- **Performance**: GOOD

---

**Auto-generated by**: SpecWeave Self-Reflection System
**Model**: Claude 3.5 Haiku
**Reflection Time**: 18 seconds
**Estimated Cost**: ~$0.009
`;

  test.beforeEach(async ({ }, testInfo) => {
    // Create unique directory for each test (parallel execution support)
    testDir = path.join(__dirname, '../../fixtures/reflection-smoke-test', `test-${testInfo.workerIndex}-${Date.now()}`);

    // Clean up and create test directory
    if (fs.existsSync(testDir)) {
      fs.removeSync(testDir);
    }
    fs.mkdirpSync(testDir);

    // Create .specweave structure
    const specweaveDir = path.join(testDir, '.specweave');
    fs.mkdirpSync(specweaveDir);

    // Create config.json with reflection enabled
    fs.writeJsonSync(path.join(specweaveDir, 'config.json'), {
      reflection: {
        enabled: true,
        mode: 'auto',
        depth: 'standard',
        model: 'haiku',
        categories: {
          security: true,
          quality: true,
          testing: true,
          performance: true,
          technicalDebt: true
        },
        criticalThreshold: 'MEDIUM',
        storeReflections: true,
        autoCreateFollowUpTasks: false,
        soundNotifications: false
      }
    });

    // Create increment structure
    const incrementDir = path.join(specweaveDir, 'increments', incrementId);
    fs.mkdirpSync(incrementDir);

    // Create spec.md
    fs.writeFileSync(path.join(incrementDir, 'spec.md'), `
# Increment ${incrementId}: Smoke Test

## User Stories

- **US-001**: As a developer, I want to test self-reflection
`);

    // Initialize git repository
    execSync('git init', { cwd: testDir });
    execSync('git config user.name "Test User"', { cwd: testDir });
    execSync('git config user.email "test@example.com"', { cwd: testDir });

    // Create initial commit
    const testFile = path.join(testDir, 'src', 'auth.ts');
    fs.mkdirpSync(path.dirname(testFile));
    fs.writeFileSync(testFile, `
export class AuthService {
  constructor() {
    // Initial implementation
  }
}
`);
    execSync('git add .', { cwd: testDir });
    execSync('git commit -m "Initial commit"', { cwd: testDir });

    // Modify file to create diff
    fs.writeFileSync(testFile, `
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';

export class AuthService {
  private jwtSecret = 'my-secret-key'; // TODO: Move to env

  async login(email: string, password: string) {
    // Add authentication logic
    const user = await this.findUser(email);
    if (!user) {
      throw new Error('User not found');
    }

    const isValid = await bcrypt.compare(password, user.passwordHash);
    if (!isValid) {
      throw new Error('Invalid password');
    }

    const token = jwt.sign({ userId: user.id }, this.jwtSecret, {
      expiresIn: '15m'
    });

    return { token, user };
  }

  private async findUser(email: string) {
    // TODO: Implement database lookup
    return null;
  }
}
`);
  });

  test.afterEach(async () => {
    // Clean up test directory after each test
    if (fs.existsSync(testDir)) {
      fs.removeSync(testDir);
    }
  });

  test('should create reflection context from git changes', () => {
    // Step 1: Create reflection context
    const context = createReflectionContext(incrementId, taskId, testDir);

    // Verify context was created successfully
    expect(context.incrementId).toBe(incrementId);
    expect(context.taskId).toBe(taskId);
    expect(context.config).toBeDefined();
    expect(context.config.enabled).toBe(true);
    expect(context.config.model).toBe('haiku');

    // Verify modified files were detected
    expect(context.modifiedFiles.length).toBeGreaterThan(0);
    expect(context.modifiedFiles[0].file).toContain('src/auth.ts');
    expect(context.modifiedFiles[0].linesAdded).toBeGreaterThan(0);
  });

  test('should build reflection prompt with correct structure', () => {
    const context = createReflectionContext(incrementId, taskId, testDir);

    // Step 2: Build reflection prompt
    const prompt = buildReflectionPrompt({
      taskId: context.taskId,
      taskName: 'Add User Authentication',
      modifiedFiles: context.modifiedFiles,
      config: context.config,
      incrementId: context.incrementId,
      includeFullDiff: false
    });

    // Verify prompt structure
    expect(prompt).toContain('# Self-Reflection Request');
    expect(prompt).toContain('**Task ID**: T-001');  // Updated to match implementation
    expect(prompt).toContain('**Task Name**: Add User Authentication');  // Updated to match implementation
    expect(prompt).toContain('## Modified Files Context');  // Updated to match implementation
    expect(prompt).toContain('src/auth.ts');
    expect(prompt).toContain('**Enabled Analysis Categories**');  // Updated to match implementation
    expect(prompt).toContain('Security');
    expect(prompt).toContain('Quality');
    expect(prompt).toContain('Testing');
    expect(prompt).toContain('Performance');
    expect(prompt).toContain('Technical Debt');
  });

  test('should parse reflection output correctly', () => {
    // Step 3: Parse agent response
    const result = parseReflectionMarkdown(
      mockAgentResponse,
      'T-001: Add User Authentication',
      ReflectionModel.HAIKU,
      18,
      0.009
    );

    // Verify parsed result
    expect(result.taskName).toBe('T-001: Add User Authentication');
    expect(result.accomplishments.length).toBe(3);
    expect(result.accomplishments[0]).toContain('JWT-based authentication');

    expect(result.strengths.length).toBe(3);
    expect(result.strengths[0]).toContain('Secure password storage');

    expect(result.issues.length).toBe(2);
    expect(result.issues[0].severity).toBe('HIGH');
    expect(result.issues[0].category).toBe('SECURITY');
    expect(result.issues[0].description).toContain('JWT secret');
    expect(result.issues[0].location?.file).toContain('auth.ts');
    expect(result.issues[0].location?.line).toBe(12);

    expect(result.recommendedActions.priority1.length).toBe(2);
    expect(result.recommendedActions.priority1[0]).toContain('JWT secret');

    expect(result.lessonsLearned.whatWentWell.length).toBe(2);
    expect(result.lessonsLearned.whatCouldImprove.length).toBe(2);
    expect(result.lessonsLearned.forNextTime.length).toBe(2);

    expect(result.metrics.codeQuality).toBe(8);
    expect(result.metrics.security).toBe(6);
    expect(result.metrics.testCoverage).toBe(75);
    expect(result.metrics.technicalDebt).toBe('LOW');
    expect(result.metrics.performance).toBe('GOOD');

    expect(result.metadata.model).toBe(ReflectionModel.HAIKU);
    expect(result.metadata.reflectionTime).toBe(18);
    expect(result.metadata.estimatedCost).toBe(0.009);
  });

  test('should save and retrieve reflection', () => {
    const result = parseReflectionMarkdown(
      mockAgentResponse,
      'T-001: Add User Authentication',
      ReflectionModel.HAIKU,
      18,
      0.009
    );

    // Step 4: Save reflection
    const savedPath = saveReflection(result, incrementId, taskId, testDir);

    // Verify file was saved
    expect(fs.existsSync(savedPath)).toBe(true);
    expect(savedPath).toContain('.specweave/increments');
    expect(savedPath).toContain(incrementId);
    expect(savedPath).toContain('logs/reflections');
    expect(savedPath).toMatch(/task-T-001-reflection-\d{4}-\d{2}-\d{2}\.md$/);

    // Step 5: List reflections
    const reflections = listReflections(incrementId, testDir);
    expect(reflections.length).toBe(1);
    expect(reflections[0]).toBe(savedPath);

    // Step 6: Read reflection
    const savedContent = readReflection(savedPath);
    expect(savedContent).toContain('# Self-Reflection');
    expect(savedContent).toContain('T-001');  // Task ID appears in title
    expect(savedContent).toContain('JWT secret');
    expect(savedContent).toContain('**Code Quality**: 8/10');
    expect(savedContent).toContain('**Security**: 6/10');
  });

  test('should prepare reflection context for hook', () => {
    // Step 7: Prepare reflection context (hook integration)
    const contextFile = prepareReflectionContext(incrementId, taskId, testDir);

    // Verify context file was created
    expect(contextFile).not.toBeNull();
    expect(fs.existsSync(contextFile!)).toBe(true);

    // Verify context can be read back
    const hasContext = hasReflectionContext(incrementId, testDir);
    expect(hasContext).toBe(true);

    const contextData = readReflectionContext(incrementId, testDir);
    expect(contextData).not.toBeNull();
    expect(contextData.incrementId).toBe(incrementId);
    expect(contextData.taskId).toBe(taskId);
    expect(contextData.modifiedFiles).toBeDefined();
    expect(contextData.modifiedFiles.length).toBeGreaterThan(0);
    expect(contextData.fileSummary).toBeDefined();
    expect(contextData.fileSummary.count).toBeGreaterThan(0);  // Fixed: count, not totalFiles
    expect(contextData.config).toBeDefined();

    // Verify context can be cleared
    clearReflectionContext(incrementId, testDir);
    expect(hasReflectionContext(incrementId, testDir)).toBe(false);
  });

  test('should handle complete end-to-end workflow', () => {
    // Complete workflow: context â†’ prompt â†’ parse â†’ save â†’ retrieve

    // 1. Create context
    const context = createReflectionContext(incrementId, 'T-002', testDir);
    expect(context.modifiedFiles.length).toBeGreaterThan(0);

    // 2. Build prompt
    const prompt = buildReflectionPrompt({
      taskId: 'T-002',
      taskName: 'Complete E2E Test',
      modifiedFiles: context.modifiedFiles,
      config: context.config,
      incrementId: context.incrementId
    });
    expect(prompt).toContain('Self-Reflection Request');

    // 3. Parse (simulated agent response)
    const result = parseReflectionMarkdown(
      mockAgentResponse,
      'T-002: Complete E2E Test',
      ReflectionModel.HAIKU,
      20,
      0.01
    );
    expect(result.taskName).toBe('T-002: Complete E2E Test');

    // 4. Save
    const savedPath = saveReflection(result, incrementId, 'T-002', testDir);
    expect(fs.existsSync(savedPath)).toBe(true);

    // 5. List and verify
    const reflections = listReflections(incrementId, testDir);
    expect(reflections.length).toBeGreaterThanOrEqual(1); // This test creates T-002

    // 6. Read and verify content
    const savedContent = readReflection(savedPath);
    expect(savedContent).toContain('T-002');
    expect(savedContent).toContain('JWT secret');
  });

  test('should skip reflection when disabled in config', () => {
    // Update config to disable reflection
    const configPath = path.join(testDir, '.specweave', 'config.json');
    const config = fs.readJsonSync(configPath);
    config.reflection.enabled = false;
    fs.writeJsonSync(configPath, config);

    // Attempt to prepare context
    const contextFile = prepareReflectionContext(incrementId, 'T-003', testDir);

    // Should return null when disabled
    expect(contextFile).toBeNull();

    // Restore config
    config.reflection.enabled = true;
    fs.writeJsonSync(configPath, config);
  });

  test('should handle no modified files gracefully', () => {
    // Commit all changes to clear working tree
    execSync('git add .', { cwd: testDir });
    execSync('git commit -m "Commit all changes" || true', { cwd: testDir });

    // Create context with no modified files
    const context = createReflectionContext(incrementId, 'T-004', testDir);
    expect(context.modifiedFiles.length).toBe(0);

    // Should not prepare context when no files modified
    const contextFile = prepareReflectionContext(incrementId, 'T-004', testDir);
    expect(contextFile).toBeNull();
  });

  test('should validate reflection result structure', () => {
    const result = parseReflectionMarkdown(
      mockAgentResponse,
      'T-005: Validation Test'
    );

    // Verify all required fields are present
    expect(result.taskName).toBeDefined();
    expect(result.completed).toBeDefined();
    expect(result.filesModified).toBeDefined();
    expect(result.accomplishments).toBeInstanceOf(Array);
    expect(result.strengths).toBeInstanceOf(Array);
    expect(result.issues).toBeInstanceOf(Array);
    expect(result.recommendedActions).toBeDefined();
    expect(result.recommendedActions.priority1).toBeInstanceOf(Array);
    expect(result.recommendedActions.priority2).toBeInstanceOf(Array);
    expect(result.recommendedActions.priority3).toBeInstanceOf(Array);
    expect(result.lessonsLearned).toBeDefined();
    expect(result.metrics).toBeDefined();
    expect(result.metadata).toBeDefined();

    // Verify issue structure
    if (result.issues.length > 0) {
      const issue = result.issues[0];
      expect(issue.severity).toBeDefined();
      expect(issue.category).toBeDefined();
      expect(issue.description).toBeDefined();
      expect(['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']).toContain(issue.severity);
      expect(['SECURITY', 'QUALITY', 'TESTING', 'PERFORMANCE', 'TECHNICAL_DEBT']).toContain(issue.category);
    }
  });

  test('should generate markdown with proper formatting', () => {
    const result = parseReflectionMarkdown(
      mockAgentResponse,
      'T-006: Markdown Test',
      ReflectionModel.HAIKU,
      15,
      0.008
    );

    const savedPath = saveReflection(result, incrementId, 'T-006', testDir);
    const markdown = readReflection(savedPath);

    // Verify markdown structure
    expect(markdown).toContain('# Self-Reflection');
    expect(markdown).toContain('## âœ… What Was Accomplished');
    expect(markdown).toContain('## ğŸ¯ Quality Assessment');
    expect(markdown).toContain('### âœ… Strengths');
    expect(markdown).toContain('### âš ï¸ Issues Identified');
    expect(markdown).toContain('## ğŸ”§ Recommended Follow-Up Actions');
    expect(markdown).toContain('## ğŸ“š Lessons Learned');
    expect(markdown).toContain('## ğŸ“Š Metrics');
    expect(markdown).toContain('**Auto-generated by**: SpecWeave Self-Reflection System');
    expect(markdown).toContain('**Model**: Claude 3.5 Haiku');
    expect(markdown).toContain('**Reflection Time**: 15 seconds');
    expect(markdown).toContain('**Estimated Cost**: ~$0.008');
  });
});
