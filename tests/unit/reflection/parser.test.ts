/**
 * Unit tests for Reflection Parser
 */

import {
  parseReflectionMarkdown,
  validateReflectionResult
} from '../../../src/hooks/lib/reflection-parser';
import {
  IssueSeverity,
  IssueCategory,
  ReflectionModel
} from '../../../src/hooks/lib/types/reflection-types';

describe('Reflection Parser', () => {
  const sampleReflection = `
# Self-Reflection: Task T-005 - Implement Reflection Engine

**Completed**: 2025-11-10 14:30 UTC
**Duration**: 45 minutes
**Files Modified**: 3 files, +287 -45

---

## ‚úÖ What Was Accomplished

Implemented the core reflection engine with the following components:

- Created run-self-reflection.ts with agent invocation logic
- Added configuration loading from .specweave/config.json
- Implemented reflection prompt builder
- Integrated with post-task-completion hook
- Set up reflection storage in increment logs

---

## üéØ Quality Assessment

### ‚úÖ Strengths

- ‚úÖ Clean separation of concerns (engine vs agent vs storage)
- ‚úÖ Type-safe configuration loading with schema validation
- ‚úÖ Comprehensive error handling with graceful degradation
- ‚úÖ Well-documented functions with JSDoc comments
- ‚úÖ Unit tests with 85% coverage

### ‚ö†Ô∏è Issues Identified

**CRITICAL (SECURITY)**
- ‚ùå API key exposed in debug logs
  - **Impact**: Potential credential leakage in log files. If logs are committed to git or shared, API keys could be compromised.
  - **Recommendation**: Redact API keys before logging. Use a utility function like \`redactSensitiveData()\` that replaces keys with \`***\`.
  - **Location**: \`src/hooks/lib/run-self-reflection.ts:45\`

**HIGH (QUALITY)**
- ‚ùå High cyclomatic complexity in reflection orchestrator
  - **Impact**: Function has complexity of 18 (threshold: 10). Difficult to test all paths, maintain, and debug.
  - **Recommendation**: Extract nested logic into separate functions: \`prepareContext()\`, \`invokeAgent()\`, \`processResponse()\`.
  - **Location**: \`src/hooks/lib/run-self-reflection.ts:120-180\`

**MEDIUM (TESTING)**
- ‚ö†Ô∏è Missing edge case tests for API failures
  - **Impact**: Unhandled error scenarios (rate limits, timeouts, network failures) may cause runtime errors in production.
  - **Recommendation**: Add test cases for rate limit errors, API timeouts, and network failures with retry logic validation.
  - **Location**: \`tests/integration/reflection/end-to-end.test.ts\`

---

## üîß Recommended Follow-Up Actions

**Priority 1 (MUST FIX - before closing increment)**:
1. Redact API keys in debug logging (CRITICAL security issue)
2. Add error handling tests for API failures

**Priority 2 (SHOULD FIX - this increment)**:
1. Refactor run-self-reflection.ts to reduce complexity
2. Add JSDoc comments to exported functions

**Priority 3 (NICE TO HAVE - future increment)**:
1. Add performance metrics tracking
2. Implement retry logic for transient failures

---

## üìö Lessons Learned

**What went well**:
- TypeScript types caught configuration errors early (prevented runtime bugs)
- Clean architecture makes testing easier (high testability)
- TDD approach helped catch edge cases during development

**What could improve**:
- Should have added API failure tests from start (would have caught error handling gaps)
- Debug logging needs security review before implementation (not after)
- Complexity could have been managed better with smaller functions from the start

**For next time**:
- Always review security implications BEFORE implementing (not during reflection)
- Write edge case tests alongside happy path tests (don't defer testing)
- Keep functions under 50 lines and complexity under 10 (easier to maintain)

---

## üìä Metrics

- **Code Quality**: 7/10
- **Security**: 6/10 (due to API key logging issue)
- **Test Coverage**: 85%
- **Technical Debt**: MEDIUM (complexity refactoring needed)
- **Performance**: GOOD (reflection completes in <25s)

---

## üîó Related Tasks

- T-006: Reflection storage manager (dependency)
- T-009: Unit tests for core components

---

**Auto-generated by**: SpecWeave Self-Reflection System
**Model**: Claude 3.5 Haiku
**Reflection Time**: 23 seconds
**Estimated Cost**: ~$0.008
`;

  describe('parseReflectionMarkdown', () => {
    it('should parse complete reflection successfully', () => {
      const result = parseReflectionMarkdown(
        sampleReflection,
        'T-005: Implement Reflection Engine',
        ReflectionModel.HAIKU,
        23,
        0.008
      );

      expect(result.taskName).toBe('T-005: Implement Reflection Engine');
      expect(result.completed).toBeDefined();
      expect(result.duration).toBe('23s');
      expect(result.metadata.model).toBe(ReflectionModel.HAIKU);
      expect(result.metadata.reflectionTime).toBe(23);
      expect(result.metadata.estimatedCost).toBe(0.008);
    });

    it('should parse accomplishments', () => {
      const result = parseReflectionMarkdown(sampleReflection, 'Test Task');

      expect(result.accomplishments.length).toBeGreaterThan(0);
      expect(result.accomplishments).toContain('Created run-self-reflection.ts with agent invocation logic');
      expect(result.accomplishments).toContain('Added configuration loading from .specweave/config.json');
    });

    it('should parse strengths', () => {
      const result = parseReflectionMarkdown(sampleReflection, 'Test Task');

      expect(result.strengths.length).toBeGreaterThan(0);
      expect(result.strengths.some(s => s.includes('Clean separation of concerns'))).toBe(true);
      expect(result.strengths.some(s => s.includes('Type-safe configuration'))).toBe(true);
    });

    it('should parse issues with all fields', () => {
      const result = parseReflectionMarkdown(sampleReflection, 'Test Task');

      expect(result.issues.length).toBe(3);

      // Check CRITICAL security issue
      const criticalIssue = result.issues.find(i => i.severity === IssueSeverity.CRITICAL);
      expect(criticalIssue).toBeDefined();
      expect(criticalIssue!.category).toBe(IssueCategory.SECURITY);
      expect(criticalIssue!.description).toContain('API key exposed');
      expect(criticalIssue!.impact).toContain('credential leakage');
      expect(criticalIssue!.recommendation).toContain('Redact API keys');
      expect(criticalIssue!.location?.file).toBe('src/hooks/lib/run-self-reflection.ts');
      expect(criticalIssue!.location?.line).toBe(45);

      // Check HIGH quality issue
      const highIssue = result.issues.find(i => i.severity === IssueSeverity.HIGH);
      expect(highIssue).toBeDefined();
      expect(highIssue!.category).toBe(IssueCategory.QUALITY);

      // Check MEDIUM testing issue
      const mediumIssue = result.issues.find(i => i.severity === IssueSeverity.MEDIUM);
      expect(mediumIssue).toBeDefined();
      expect(mediumIssue!.category).toBe(IssueCategory.TESTING);
    });

    it('should parse recommended actions by priority', () => {
      const result = parseReflectionMarkdown(sampleReflection, 'Test Task');

      expect(result.recommendedActions.priority1.length).toBe(2);
      expect(result.recommendedActions.priority2.length).toBe(2);
      expect(result.recommendedActions.priority3.length).toBe(2);

      expect(result.recommendedActions.priority1[0]).toContain('Redact API keys');
      expect(result.recommendedActions.priority2[0]).toContain('Refactor');
      expect(result.recommendedActions.priority3[0]).toContain('performance metrics');
    });

    it('should parse lessons learned', () => {
      const result = parseReflectionMarkdown(sampleReflection, 'Test Task');

      expect(result.lessonsLearned.whatWentWell.length).toBe(3);
      expect(result.lessonsLearned.whatCouldImprove.length).toBe(3);
      expect(result.lessonsLearned.forNextTime.length).toBe(3);

      expect(result.lessonsLearned.whatWentWell).toContain('TypeScript types caught configuration errors early (prevented runtime bugs)');
      expect(result.lessonsLearned.forNextTime.some(l => l.includes('security implications'))).toBe(true);
    });

    it('should parse metrics', () => {
      const result = parseReflectionMarkdown(sampleReflection, 'Test Task');

      expect(result.metrics.codeQuality).toBe(7);
      expect(result.metrics.security).toBe(6);
      expect(result.metrics.testCoverage).toBe(85);
      expect(result.metrics.technicalDebt).toBe('MEDIUM');
      expect(result.metrics.performance).toBe('GOOD');
    });

    it('should parse files modified stats', () => {
      const result = parseReflectionMarkdown(sampleReflection, 'Test Task');

      expect(result.filesModified.count).toBe(3);
      expect(result.filesModified.linesAdded).toBe(287);
      expect(result.filesModified.linesRemoved).toBe(45);
    });

    it('should handle missing sections gracefully', () => {
      const minimalReflection = `
# Self-Reflection

## ‚úÖ What Was Accomplished

- Task completed

## üéØ Quality Assessment

### ‚úÖ Strengths

- ‚úÖ Good work

### ‚ö†Ô∏è Issues Identified

‚úÖ No critical issues detected. Code follows best practices.

## üìä Metrics

- **Code Quality**: 8/10
- **Security**: 9/10
- **Test Coverage**: N/A
- **Technical Debt**: LOW
- **Performance**: GOOD
`;

      const result = parseReflectionMarkdown(minimalReflection, 'Test Task');

      expect(result.accomplishments.length).toBeGreaterThan(0);
      expect(result.strengths.length).toBeGreaterThan(0);
      expect(result.issues.length).toBe(0); // No issues parsed
      expect(result.recommendedActions.priority1.length).toBe(0);
      expect(result.lessonsLearned.whatWentWell.length).toBe(0);
      expect(result.metrics.testCoverage).toBeUndefined();
    });

    it('should handle variations in markdown formatting', () => {
      const variantReflection = `
## ‚úÖ What Was Accomplished

* Bullet with asterisk
+ Bullet with plus
- Bullet with dash

## üéØ Quality Assessment

### ‚úÖ Strengths

‚úÖ Strength without bullet
- ‚úÖ Strength with bullet

### ‚ö†Ô∏è Issues Identified

**CRITICAL (SECURITY)**
‚ùå Issue without bullet
  **Impact**: Impact text
  **Recommendation**: Recommendation text
  **Location**: \`file.ts:10\`

## üîß Recommended Follow-Up Actions

**Priority 1 (MUST FIX)**:
* Action with asterisk

**Priority 2 (SHOULD FIX)**:
+ Action with plus

**Priority 3 (NICE TO HAVE)**:
- Action with dash

## üìö Lessons Learned

**What went well**:
* Good thing

**What could improve**:
+ Improvement

**For next time**:
- Next time action

## üìä Metrics

- Code Quality: 5/10
- Security: 7/10
- Test Coverage: 90%
- Technical Debt: HIGH
- Performance: NEEDS WORK
`;

      const result = parseReflectionMarkdown(variantReflection, 'Test Task');

      expect(result.accomplishments.length).toBe(3);
      expect(result.strengths.length).toBe(2);
      expect(result.issues.length).toBe(1);
      expect(result.recommendedActions.priority1.length).toBe(1);
      expect(result.lessonsLearned.whatWentWell.length).toBe(1);
      expect(result.metrics.performance).toBe('NEEDS_WORK');
    });
  });

  describe('validateReflectionResult', () => {
    it('should validate complete reflection result', () => {
      const result = parseReflectionMarkdown(sampleReflection, 'Test Task');
      const validation = validateReflectionResult(result);

      expect(validation.valid).toBe(true);
      expect(validation.errors).toHaveLength(0);
    });

    it('should reject missing task name', () => {
      const result = parseReflectionMarkdown(sampleReflection, '');
      const validation = validateReflectionResult(result);

      expect(validation.valid).toBe(false);
      expect(validation.errors).toContain('Missing task name');
    });

    it('should reject empty reflection (no content)', () => {
      const emptyReflection = `
# Self-Reflection

## ‚úÖ What Was Accomplished

## üéØ Quality Assessment

### ‚úÖ Strengths

### ‚ö†Ô∏è Issues Identified

## üìä Metrics

- Code Quality: 5/10
- Security: 5/10
`;

      const result = parseReflectionMarkdown(emptyReflection, 'Test Task');
      const validation = validateReflectionResult(result);

      expect(validation.valid).toBe(false);
      expect(validation.errors.some(e => e.includes('too sparse'))).toBe(true);
    });

    it('should reject invalid metric values', () => {
      const result = parseReflectionMarkdown(sampleReflection, 'Test Task');
      result.metrics.codeQuality = 15; // Invalid (> 10)

      const validation = validateReflectionResult(result);

      expect(validation.valid).toBe(false);
      expect(validation.errors).toContain('Code quality must be 1-10');
    });

    it('should reject invalid test coverage', () => {
      const result = parseReflectionMarkdown(sampleReflection, 'Test Task');
      result.metrics.testCoverage = 150; // Invalid (> 100)

      const validation = validateReflectionResult(result);

      expect(validation.valid).toBe(false);
      expect(validation.errors).toContain('Test coverage must be 0-100%');
    });

    it('should reject issues missing required fields', () => {
      const result = parseReflectionMarkdown(sampleReflection, 'Test Task');
      result.issues[0].description = ''; // Remove description

      const validation = validateReflectionResult(result);

      expect(validation.valid).toBe(false);
      expect(validation.errors).toContain('Issue missing description');
    });
  });

  describe('Edge Cases', () => {
    it('should handle empty markdown', () => {
      const result = parseReflectionMarkdown('', 'Test Task');

      expect(result.taskName).toBe('Test Task');
      expect(result.accomplishments).toEqual([]);
      expect(result.strengths).toEqual([]);
      expect(result.issues).toEqual([]);
    });

    it('should handle markdown with only headers', () => {
      const headersOnly = `
## ‚úÖ What Was Accomplished
## üéØ Quality Assessment
### ‚úÖ Strengths
### ‚ö†Ô∏è Issues Identified
## üìä Metrics
`;

      const result = parseReflectionMarkdown(headersOnly, 'Test Task');

      expect(result.accomplishments).toEqual([]);
      expect(result.strengths).toEqual([]);
      expect(result.issues).toEqual([]);
    });

    it('should handle issues without location', () => {
      const noLocationReflection = `
### ‚ö†Ô∏è Issues Identified

**MEDIUM (QUALITY)**
- ‚ùå Code could be improved
  - **Impact**: Maintainability
  - **Recommendation**: Refactor
`;

      const result = parseReflectionMarkdown(noLocationReflection, 'Test Task');

      expect(result.issues.length).toBe(1);
      expect(result.issues[0].location).toBeUndefined();
    });

    it('should handle metrics with N/A values', () => {
      const naMetrics = `
## üìä Metrics

- Code Quality: 7/10
- Security: 8/10
- Test Coverage: N/A
- Technical Debt: LOW
- Performance: ACCEPTABLE
`;

      const result = parseReflectionMarkdown(naMetrics, 'Test Task');

      expect(result.metrics.testCoverage).toBeUndefined();
      expect(result.metrics.codeQuality).toBe(7);
    });
  });
});
