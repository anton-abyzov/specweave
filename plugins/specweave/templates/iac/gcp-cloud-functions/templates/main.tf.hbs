# GCP Cloud Functions + Firestore Terraform Configuration
# Generated by SpecWeave Serverless Architecture Intelligence

# Enable required APIs
resource "google_project_service" "cloudfunctions" {
  project = "{{projectId}}"
  service = "cloudfunctions.googleapis.com"

  disable_on_destroy = false
}

resource "google_project_service" "cloudbuild" {
  project = "{{projectId}}"
  service = "cloudbuild.googleapis.com"

  disable_on_destroy = false
}

resource "google_project_service" "firestore" {
  project = "{{projectId}}"
  service = "firestore.googleapis.com"

  disable_on_destroy = false
}

resource "google_project_service" "run" {
  project = "{{projectId}}"
  service = "run.googleapis.com"

  disable_on_destroy = false
}

# Service Account for Cloud Function
resource "google_service_account" "{{snakeCase serviceAccountId}}" {
  account_id   = "{{serviceAccountId}}"
  display_name = "Service Account for {{functionName}}"
  project      = "{{projectId}}"
}

# IAM binding for Firestore access
resource "google_project_iam_member" "firestore_user" {
  project = "{{projectId}}"
  role    = "roles/datastore.user"
  member  = "serviceAccount:${google_service_account.{{snakeCase serviceAccountId}}.email}"
}

# Storage Bucket for function source code
resource "google_storage_bucket" "{{snakeCase bucketName}}" {
  name     = "{{bucketName}}-{{projectId}}"
  location = "{{bucketLocation}}"
  project  = "{{projectId}}"

  uniform_bucket_level_access = true

  labels = {
    environment = "{{environment}}"
    managed_by  = "terraform"
    project     = "{{projectName}}"
  }
}

# Storage Bucket Object for function source code (placeholder)
resource "google_storage_bucket_object" "function_source" {
  name   = "function-source-{{environment}}.zip"
  bucket = google_storage_bucket.{{snakeCase bucketName}}.name
  source = "function-source.zip"  # You need to provide this file
}

# Cloud Function (2nd generation)
resource "google_cloudfunctions2_function" "{{snakeCase functionName}}" {
  name     = "{{functionName}}"
  location = "{{region}}"
  project  = "{{projectId}}"

  build_config {
    runtime     = "{{runtime}}"
    entry_point = "{{entryPoint}}"

    source {
      storage_source {
        bucket = google_storage_bucket.{{snakeCase bucketName}}.name
        object = google_storage_bucket_object.function_source.name
      }
    }
  }

  service_config {
    max_instance_count = {{maxInstances}}
    min_instance_count = {{minInstances}}
    available_memory   = "{{memoryMb}}M"
    timeout_seconds    = {{timeoutSeconds}}

    {{#if enableConcurrency}}
    max_instance_request_concurrency = {{maxConcurrentRequests}}
    {{/if}}

    environment_variables = {
      ENVIRONMENT      = "{{environment}}"
      GCP_PROJECT      = "{{projectId}}"
      FIRESTORE_DATABASE = "{{databaseId}}"
      COLLECTION_ID    = "{{collectionId}}"
      {{#if customEnvVars}}
      {{#each customEnvVars}}
      {{@key}} = "{{this}}"
      {{/each}}
      {{/if}}
    }

    service_account_email = google_service_account.{{snakeCase serviceAccountId}}.email

    {{#if enableVpc}}
    vpc_connector                 = google_vpc_access_connector.connector.id
    vpc_connector_egress_settings = "ALL_TRAFFIC"
    {{/if}}

    {{#if corsOrigins}}
    ingress_settings = "ALLOW_ALL"
    {{/if}}
  }

  labels = {
    environment = "{{environment}}"
    managed_by  = "terraform"
    project     = "{{projectName}}"
  }

  depends_on = [
    google_project_service.cloudfunctions,
    google_project_service.cloudbuild,
    google_project_service.run,
    google_project_iam_member.firestore_user
  ]
}

# Cloud Function IAM - Allow unauthenticated invocations (API Gateway equivalent)
resource "google_cloudfunctions2_function_iam_member" "invoker" {
  project        = google_cloudfunctions2_function.{{snakeCase functionName}}.project
  location       = google_cloudfunctions2_function.{{snakeCase functionName}}.location
  cloud_function = google_cloudfunctions2_function.{{snakeCase functionName}}.name

  role   = "roles/cloudfunctions.invoker"
  member = "allUsers"  # For public API. Use specific members for private APIs
}

# Firestore Database
resource "google_firestore_database" "{{snakeCase databaseId}}" {
  project     = "{{projectId}}"
  name        = "{{databaseId}}"
  location_id = "{{region}}"
  type        = "FIRESTORE_NATIVE"

  concurrency_mode            = "OPTIMISTIC"
  app_engine_integration_mode = "DISABLED"

  depends_on = [google_project_service.firestore]
}

{{#if enableVpc}}
# VPC Access Connector for private networking
resource "google_vpc_access_connector" "connector" {
  name          = "{{functionName}}-vpc-connector"
  region        = "{{region}}"
  project       = "{{projectId}}"
  ip_cidr_range = "10.8.0.0/28"
  network       = var.vpc_network
}
{{/if}}

{{#if enableSecretManager}}
# Secret Manager for sensitive configuration
resource "google_secret_manager_secret" "{{snakeCase functionName}}_secrets" {
  secret_id = "{{functionName}}-secrets"
  project   = "{{projectId}}"

  replication {
    auto {}
  }

  labels = {
    environment = "{{environment}}"
    managed_by  = "terraform"
  }
}

# IAM binding for Secret Manager access
resource "google_secret_manager_secret_iam_member" "secret_accessor" {
  project   = google_secret_manager_secret.{{snakeCase functionName}}_secrets.project
  secret_id = google_secret_manager_secret.{{snakeCase functionName}}_secrets.secret_id
  role      = "roles/secretmanager.secretAccessor"
  member    = "serviceAccount:${google_service_account.{{snakeCase serviceAccountId}}.email}"
}
{{/if}}
