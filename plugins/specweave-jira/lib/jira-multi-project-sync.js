import { JiraClient } from "../../../src/integrations/jira/jira-client.js";
import {
  getPrimaryProject,
  suggestJiraItemType,
  mapUserStoryToProjects
} from "../../../src/utils/project-mapper.js";
import { parseSpecFile } from "../../../src/utils/spec-splitter.js";
class JiraMultiProjectSync {
  constructor(config) {
    this.config = config;
    this.client = new JiraClient({
      domain: config.domain,
      email: config.email,
      apiToken: config.apiToken
    });
  }
  /**
   * Pre-flight validation: Verify all JIRA projects exist
   *
   * @throws Error if any projects are missing
   */
  async validateProjects() {
    if (!this.config.projects || this.config.projects.length === 0) {
      throw new Error("No JIRA projects configured for validation");
    }
    const missing = await validateJiraProjects(this.client, this.config.projects);
    if (missing.length > 0) {
      throw new Error(
        `\u274C Pre-flight check failed: Missing JIRA projects:
` + missing.map((p) => `  - ${p} (${this.config.domain})`).join("\n") + `

Please verify project keys and access permissions.`
      );
    }
  }
  /**
   * Sync spec to JIRA projects with intelligent mapping
   *
   * @param specPath Path to spec file
   * @returns Array of sync results
   */
  async syncSpec(specPath) {
    const results = [];
    await this.validateProjects();
    const parsedSpec = await parseSpecFile(specPath);
    const epicsByProject = /* @__PURE__ */ new Map();
    if (this.config.autoCreateEpics !== false) {
      for (const project of this.config.projects) {
        const epicResult = await this.createEpicForProject(parsedSpec, project);
        epicsByProject.set(project, epicResult.issueKey);
        results.push(epicResult);
      }
    }
    const projectStories = /* @__PURE__ */ new Map();
    for (const userStory of parsedSpec.userStories) {
      if (this.config.intelligentMapping !== false) {
        const mapperConfig = {
          confidenceThreshold: this.config.confidenceThreshold
        };
        const primary = getPrimaryProject(userStory, void 0, mapperConfig);
        if (primary) {
          const existing = projectStories.get(primary.projectId) || [];
          existing.push({ story: userStory, confidence: primary.confidence });
          projectStories.set(primary.projectId, existing);
        } else {
          const mappings = mapUserStoryToProjects(userStory);
          const threshold = this.config.confidenceThreshold ?? 0.3;
          console.warn(`\u26A0\uFE0F  Low confidence for ${userStory.id} (${(mappings[0]?.confidence || 0) * 100}% < ${threshold * 100}% threshold) - assigning to ${this.config.projects[0]}`);
          const fallback = this.config.projects[0];
          const existing = projectStories.get(fallback) || [];
          existing.push({ story: userStory, confidence: mappings[0]?.confidence || 0 });
          projectStories.set(fallback, existing);
        }
      } else {
        const projectHint = this.extractProjectHint(userStory);
        if (projectHint && this.config.projects.includes(projectHint)) {
          const existing = projectStories.get(projectHint) || [];
          existing.push({ story: userStory, confidence: 1 });
          projectStories.set(projectHint, existing);
        } else {
          const fallback = this.config.projects[0];
          const existing = projectStories.get(fallback) || [];
          existing.push({ story: userStory, confidence: 0 });
          projectStories.set(fallback, existing);
        }
      }
    }
    for (const [projectId, stories] of projectStories.entries()) {
      const epicKey = epicsByProject.get(projectId);
      for (const { story, confidence } of stories) {
        const result = await this.createIssueForUserStory(projectId, story, epicKey, confidence);
        results.push(result);
      }
    }
    return results;
  }
  /**
   * Create epic for project
   */
  async createEpicForProject(parsedSpec, projectId) {
    const summary = `${parsedSpec.metadata.title} - ${projectId}`;
    const description = `h2. ${projectId} Implementation

*Status*: ${parsedSpec.metadata.status}
*Priority*: ${parsedSpec.metadata.priority}
*Estimated Effort*: ${parsedSpec.metadata.estimatedEffort || "TBD"}

h3. Executive Summary

${parsedSpec.executiveSummary}

h3. Scope (${projectId})

This epic covers all ${projectId}-related user stories for "${parsedSpec.metadata.title}".

User stories will be added as child issues.

---

\u{1F916} Auto-generated by SpecWeave
`;
    const issue = await this.client.createIssue({
      project: { key: projectId },
      summary,
      description,
      issuetype: { name: this.config.itemTypeMapping?.epic || "Epic" }
    });
    return {
      project: projectId,
      issueKey: issue.key,
      issueType: "Epic",
      summary,
      url: `https://${this.config.domain}/browse/${issue.key}`,
      action: "created"
    };
  }
  /**
   * Create issue for user story
   */
  async createIssueForUserStory(projectId, userStory, epicKey, confidence) {
    const summary = `${userStory.id}: ${userStory.title}`;
    const itemType = suggestJiraItemType(userStory);
    const description = `h3. ${userStory.title}

${userStory.description}

h4. Acceptance Criteria

${userStory.acceptanceCriteria.map((ac, i) => `* ${ac}`).join("\n")}

${userStory.technicalContext ? `
h4. Technical Context

${userStory.technicalContext}
` : ""}

${confidence !== void 0 ? `
_Classification confidence: ${(confidence * 100).toFixed(0)}%_
` : ""}

\u{1F916} Auto-generated by SpecWeave
`;
    const issueData = {
      project: { key: projectId },
      summary,
      description,
      issuetype: { name: this.getIssueTypeName(itemType) }
    };
    if (epicKey) {
      issueData.parent = { key: epicKey };
    }
    const issue = await this.client.createIssue(issueData);
    return {
      project: projectId,
      issueKey: issue.key,
      issueType: itemType,
      summary,
      url: `https://${this.config.domain}/browse/${issue.key}`,
      action: "created",
      confidence
    };
  }
  /**
   * Get JIRA issue type name from suggested type
   */
  getIssueTypeName(itemType) {
    const mapping = this.config.itemTypeMapping || {};
    switch (itemType) {
      case "Epic":
        return mapping.epic || "Epic";
      case "Story":
        return mapping.story || "Story";
      case "Task":
        return mapping.task || "Task";
      case "Subtask":
        return mapping.subtask || "Sub-task";
      default:
        return "Story";
    }
  }
  /**
   * Extract project hint from user story (manual override)
   *
   * Looks for hints like:
   * - Title: "[FE] Login UI"
   * - Description: "Project: FE"
   * - Technical context: "Frontend: React"
   */
  extractProjectHint(userStory) {
    const titleMatch = userStory.title.match(/^\[([A-Z]+)\]/);
    if (titleMatch) {
      return titleMatch[1];
    }
    const descMatch = userStory.description.match(/Project:\s*([A-Z]+)/i);
    if (descMatch) {
      return descMatch[1].toUpperCase();
    }
    return void 0;
  }
}
function formatJiraSyncResults(results) {
  const lines = [];
  lines.push("\u{1F4CA} JIRA Multi-Project Sync Results:\n");
  const byProject = /* @__PURE__ */ new Map();
  for (const result of results) {
    const existing = byProject.get(result.project) || [];
    existing.push(result);
    byProject.set(result.project, existing);
  }
  for (const [project, projectResults] of byProject.entries()) {
    lines.push(`
**JIRA Project ${project}**:`);
    for (const result of projectResults) {
      const icon = result.action === "created" ? "\u2705" : result.action === "updated" ? "\u{1F504}" : "\u23ED\uFE0F";
      const confidence = result.confidence !== void 0 ? ` (${(result.confidence * 100).toFixed(0)}% confidence)` : "";
      lines.push(`  ${icon} ${result.issueKey} [${result.issueType}]: ${result.summary}${confidence}`);
      lines.push(`     ${result.url}`);
    }
  }
  lines.push(`
\u2705 Total: ${results.length} issues synced
`);
  const epicCount = results.filter((r) => r.issueType === "Epic").length;
  const storyCount = results.filter((r) => r.issueType === "Story").length;
  const taskCount = results.filter((r) => r.issueType === "Task").length;
  const subtaskCount = results.filter((r) => r.issueType === "Subtask").length;
  lines.push("\u{1F4C8} Item Type Distribution:");
  if (epicCount > 0) lines.push(`  - Epics: ${epicCount}`);
  if (storyCount > 0) lines.push(`  - Stories: ${storyCount}`);
  if (taskCount > 0) lines.push(`  - Tasks: ${taskCount}`);
  if (subtaskCount > 0) lines.push(`  - Subtasks: ${subtaskCount}`);
  return lines.join("\n");
}
async function validateJiraProjects(client, projectKeys) {
  const missing = [];
  for (const key of projectKeys) {
    try {
      await client.getProject(key);
    } catch (error) {
      missing.push(key);
    }
  }
  return missing;
}
export {
  JiraMultiProjectSync,
  formatJiraSyncResults,
  validateJiraProjects
};
