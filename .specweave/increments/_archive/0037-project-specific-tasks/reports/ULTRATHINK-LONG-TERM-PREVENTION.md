# ULTRATHINK: Long-Term Prevention of Task Inconsistencies

**Date**: 2025-11-16
**Context**: Preventing header vs checkbox discrepancies from ever happening again
**Scope**: Architectural solution for task completion tracking

---

## üß† Deep Analysis: Why Inconsistencies Happen

### The Fundamental Problem

**Multiple Sources of Truth** create confusion:

1. **Task Header Marker**: `### T-001: Task name ‚úÖ COMPLETE`
2. **Implementation Checkboxes**: `- [x] Step 1`, `- [x] Step 2`
3. **Status Line**: `**Status**: [x] Completed`
4. **TodoWrite State**: In-memory task list during session

**Any of these can be modified independently**, creating drift.

### How We Got Here (Timeline)

**Original Design** (tasks.md v1):
- Only "**Status**: [x] Completed" line
- Single source of truth ‚úÖ
- But hard to scan visually

**Enhancement 1** (Adding ‚úÖ markers):
- Added visual indicator in header
- Easier to scan tasks.md ‚úÖ
- But now TWO places to mark complete ‚ö†Ô∏è

**Enhancement 2** (Implementation checkboxes):
- Granular tracking of sub-steps
- Better visibility into what was done ‚úÖ
- But now THREE places to mark complete ‚ö†Ô∏è‚ö†Ô∏è

**Enhancement 3** (TodoWrite integration):
- Real-time task tracking during session
- Hook auto-updates tasks.md ‚úÖ
- But hook logic was lenient ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è

**Result**: 4 sources of truth, no enforcement of consistency

---

## üéØ Core Architectural Principles

### Principle 1: Single Source of Truth (SSOT)

**Definition**: ONE canonical location stores task completion state

**Options**:

| Source | Pros | Cons | Verdict |
|--------|------|------|---------|
| **Implementation Checkboxes** | Most granular, shows what was done | Can be tedious to mark all | ‚úÖ **BEST** |
| **Task Header Marker** | Easy to scan, visual | No granularity, easy to fake | ‚ùå Derived |
| **Status Line** | Legacy format | Redundant, duplicate info | ‚ùå Deprecated |
| **TodoWrite State** | Real-time during session | Lost after session ends | ‚ùå Ephemeral |

**Decision**: **Implementation checkboxes are the SSOT**

**Rationale**:
- Checkboxes represent **actual work done** (each checkbox = specific deliverable)
- Header marker is **derived state** (computed from checkboxes)
- Status line is **legacy** (can be removed)
- TodoWrite is **ephemeral** (only exists during session)

---

### Principle 2: Derived State Must Be Computed, Never Manually Set

**Bad Pattern** (Current):
```markdown
### T-001: Task name ‚úÖ COMPLETE  ‚Üê Manually added by human

**Implementation**:
- [ ] Step 1  ‚Üê Forgot to mark
- [ ] Step 2  ‚Üê Forgot to mark
```

**Good Pattern** (Proposed):
```markdown
### T-001: Task name  ‚Üê No manual marker allowed

**Implementation**:
- [x] Step 1  ‚Üê SSOT
- [x] Step 2  ‚Üê SSOT

<!-- Auto-generated by hook: ‚úÖ COMPLETE (DO NOT EDIT) -->
```

**Enforcement**:
- Hook auto-adds/removes "‚úÖ COMPLETE" based on checkboxes
- Humans ONLY mark checkboxes
- Header marker is read-only (computed)

---

### Principle 3: Validation at Every Entry Point

**Entry Points** where task state can change:

1. **Manual Edit** (human edits tasks.md directly)
2. **TodoWrite** (marks task complete during session)
3. **Hook Execution** (post-task-completion.sh)
4. **Git Pre-Commit** (before committing changes)
5. **CI/CD** (before merging PR)

**Validation Required at EVERY Entry Point**:
- Check if header marker matches checkboxes
- Warn or auto-fix inconsistencies
- Block commit/PR if validation fails

---

## üèóÔ∏è Architectural Solution

### Layer 1: SSOT Enforcement

**File**: `src/core/increment/task-state-manager.ts` (new)

```typescript
/**
 * Task State Manager - Single Source of Truth
 *
 * Enforces that implementation checkboxes are the ONLY way to mark tasks complete.
 * Header markers are DERIVED and auto-computed.
 */

export interface TaskState {
  taskId: string;
  implementationCheckboxes: {
    total: number;
    checked: number;
  };
  isComplete: boolean; // Computed from checkboxes
  headerMarker: string | null; // "‚úÖ COMPLETE" or null
  isConsistent: boolean; // Do checkboxes and header match?
}

export class TaskStateManager {
  /**
   * Compute task state from SSOT (implementation checkboxes)
   */
  computeTaskState(taskContent: string): TaskState {
    const checkboxes = this.extractCheckboxes(taskContent);
    const total = checkboxes.length;
    const checked = checkboxes.filter(c => c.checked).length;
    const isComplete = total > 0 && checked === total;

    return {
      taskId: this.extractTaskId(taskContent),
      implementationCheckboxes: { total, checked },
      isComplete,
      headerMarker: isComplete ? '‚úÖ COMPLETE' : null,
      isConsistent: true // By definition, since we computed from SSOT
    };
  }

  /**
   * Validate task consistency
   */
  validate(taskContent: string): ValidationResult {
    const actual = this.extractHeaderMarker(taskContent);
    const expected = this.computeTaskState(taskContent).headerMarker;

    if (actual !== expected) {
      return {
        valid: false,
        error: `Header marker mismatch: expected "${expected}", got "${actual}"`,
        fix: this.autoFixHeader(taskContent)
      };
    }

    return { valid: true };
  }

  /**
   * Auto-fix header to match SSOT
   */
  autoFixHeader(taskContent: string): string {
    const state = this.computeTaskState(taskContent);
    return this.setHeaderMarker(taskContent, state.headerMarker);
  }
}
```

**Benefits**:
- Single class manages all task state logic
- Checkboxes are SSOT by design
- Header markers are always computed (never manually set)
- Validation is built-in

---

### Layer 2: Hook Integration

**File**: `plugins/specweave/lib/hooks/update-tasks-md.ts` (enhanced)

```typescript
/**
 * Enhanced Hook - Auto-computes header markers from checkboxes
 */

import { TaskStateManager } from '../../../../dist/src/core/increment/task-state-manager.js';

async function updateTasksMd(incrementId: string): Promise<void> {
  const manager = new TaskStateManager();
  const tasksPath = path.join(process.cwd(), '.specweave/increments', incrementId, 'tasks.md');

  let content = await fs.readFile(tasksPath, 'utf-8');
  const tasks = parseAllTasks(content);

  let updated = content;
  let inconsistentCount = 0;

  for (const task of tasks) {
    const validation = manager.validate(task.content);

    if (!validation.valid) {
      console.warn(`‚ö†Ô∏è  ${task.id}: ${validation.error}`);
      updated = updated.replace(task.content, validation.fix);
      inconsistentCount++;
    }
  }

  if (inconsistentCount > 0) {
    console.log(`üîß Auto-fixed ${inconsistentCount} inconsistent task(s)`);
    await fs.writeFile(tasksPath, updated, 'utf-8');
  }
}
```

**Behavior**:
- Scans ALL tasks on every run
- Validates header markers match checkboxes
- Auto-fixes any inconsistencies
- Reports what was fixed

**Result**: tasks.md is ALWAYS consistent after hook runs

---

### Layer 3: Git Pre-Commit Hook

**File**: `.git/hooks/pre-commit` (new)

```bash
#!/bin/bash
# Pre-commit hook: Validate task consistency before commit

echo "üîç Validating task consistency..."

# Run validation on all increments
node dist/src/cli/commands/validate-tasks.js --all

if [ $? -ne 0 ]; then
  echo "‚ùå Task validation failed!"
  echo "   Fix inconsistencies before committing."
  echo "   Run: npm run fix-tasks"
  exit 1
fi

echo "‚úÖ All tasks consistent"
```

**Benefits**:
- Blocks commits with inconsistent tasks
- Forces developer to fix before committing
- Prevents pollution of git history

---

### Layer 4: CI/CD Validation

**File**: `.github/workflows/validate-tasks.yml` (new)

```yaml
name: Validate Task Consistency

on:
  pull_request:
    paths:
      - '.specweave/increments/**/tasks.md'

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm ci
      - run: npm run build
      - run: node dist/src/cli/commands/validate-tasks.js --all --strict
        name: Validate all tasks.md files
      - name: Report Validation Errors
        if: failure()
        run: |
          echo "‚ùå Task validation failed in CI"
          echo "Fix inconsistencies before merging"
          exit 1
```

**Benefits**:
- Prevents merging PRs with inconsistent tasks
- Enforces consistency across team
- Automated, no manual review needed

---

### Layer 5: TodoWrite Integration

**File**: `src/core/todo-writer.ts` (enhanced)

```typescript
/**
 * Enhanced TodoWrite - Auto-updates checkboxes, never headers
 */

export class TodoWriter {
  async markTaskComplete(taskId: string) {
    const tasksPath = this.getTasksPath();
    const content = await fs.readFile(tasksPath, 'utf-8');

    // Find task's implementation section
    const task = this.parseTask(content, taskId);

    // Mark ALL checkboxes as [x]
    const updated = this.markAllCheckboxes(task.content, true);

    // DO NOT touch header marker - let hook compute it
    content = content.replace(task.content, updated);

    await fs.writeFile(tasksPath, content, 'utf-8');

    // Trigger hook to compute header marker
    await this.runHook('post-task-completion');
  }
}
```

**Behavior**:
- TodoWrite ONLY marks checkboxes
- Never touches header markers
- Hook auto-computes markers after TodoWrite completes

**Result**: No way for TodoWrite to create inconsistencies

---

## üß™ Testing Strategy

### Test 1: Unit Tests (TaskStateManager)

**File**: `tests/unit/task-state-manager.test.ts`

```typescript
describe('TaskStateManager', () => {
  describe('computeTaskState', () => {
    it('marks task complete when all checkboxes checked', () => {
      const task = `
### T-001: Task name

**Implementation**:
- [x] Step 1
- [x] Step 2
      `;

      const state = manager.computeTaskState(task);

      expect(state.isComplete).toBe(true);
      expect(state.headerMarker).toBe('‚úÖ COMPLETE');
      expect(state.implementationCheckboxes).toEqual({
        total: 2,
        checked: 2
      });
    });

    it('marks task incomplete when some checkboxes unchecked', () => {
      const task = `
### T-001: Task name

**Implementation**:
- [x] Step 1
- [ ] Step 2
      `;

      const state = manager.computeTaskState(task);

      expect(state.isComplete).toBe(false);
      expect(state.headerMarker).toBe(null);
    });
  });

  describe('validate', () => {
    it('detects header marker inconsistency', () => {
      const task = `
### T-001: Task name ‚úÖ COMPLETE

**Implementation**:
- [ ] Step 1
- [ ] Step 2
      `;

      const result = manager.validate(task);

      expect(result.valid).toBe(false);
      expect(result.error).toContain('Header marker mismatch');
    });

    it('passes validation when consistent', () => {
      const task = `
### T-001: Task name ‚úÖ COMPLETE

**Implementation**:
- [x] Step 1
- [x] Step 2
      `;

      const result = manager.validate(task);

      expect(result.valid).toBe(true);
    });
  });

  describe('autoFixHeader', () => {
    it('adds marker when all checkboxes checked', () => {
      const task = `
### T-001: Task name

**Implementation**:
- [x] Step 1
- [x] Step 2
      `;

      const fixed = manager.autoFixHeader(task);

      expect(fixed).toContain('### T-001: Task name ‚úÖ COMPLETE');
    });

    it('removes marker when checkboxes incomplete', () => {
      const task = `
### T-001: Task name ‚úÖ COMPLETE

**Implementation**:
- [x] Step 1
- [ ] Step 2
      `;

      const fixed = manager.autoFixHeader(task);

      expect(fixed).not.toContain('‚úÖ COMPLETE');
    });
  });
});
```

---

### Test 2: Integration Tests (Hook)

**File**: `tests/integration/hooks/task-consistency.test.ts`

```typescript
describe('Task Consistency Hook', () => {
  it('auto-fixes inconsistent header markers', async () => {
    // Setup: Create tasks.md with inconsistency
    const tasksPath = path.join(testIncrement, 'tasks.md');
    await fs.writeFile(tasksPath, `
### T-001: Task name ‚úÖ COMPLETE

**Implementation**:
- [ ] Step 1  ‚Üê Unchecked but header says COMPLETE
- [ ] Step 2
    `);

    // Execute: Run hook
    await execAsync('node plugins/specweave/lib/hooks/update-tasks-md.js test-increment');

    // Verify: Header marker removed
    const updated = await fs.readFile(tasksPath, 'utf-8');
    expect(updated).not.toContain('‚úÖ COMPLETE');
  });

  it('adds marker when all checkboxes checked', async () => {
    // Setup: All checked but no marker
    const tasksPath = path.join(testIncrement, 'tasks.md');
    await fs.writeFile(tasksPath, `
### T-001: Task name

**Implementation**:
- [x] Step 1
- [x] Step 2
    `);

    // Execute: Run hook
    await execAsync('node plugins/specweave/lib/hooks/update-tasks-md.js test-increment');

    // Verify: Marker added
    const updated = await fs.readFile(tasksPath, 'utf-8');
    expect(updated).toContain('‚úÖ COMPLETE');
  });

  it('syncs ACs after fixing tasks', async () => {
    // Setup: Task with AC mapping
    const tasksPath = path.join(testIncrement, 'tasks.md');
    const specPath = path.join(testIncrement, 'spec.md');

    await fs.writeFile(tasksPath, `
### T-001: Task name
**AC**: AC-US1-01

**Implementation**:
- [x] Step 1
- [x] Step 2
    `);

    await fs.writeFile(specPath, `
- [ ] **AC-US1-01**: Requirement
    `);

    // Execute: Run hook
    await execAsync('node plugins/specweave/lib/hooks/update-tasks-md.js test-increment');

    // Verify: AC auto-checked
    const spec = await fs.readFile(specPath, 'utf-8');
    expect(spec).toContain('- [x] **AC-US1-01**');
  });
});
```

---

### Test 3: E2E Tests (Full Workflow)

**File**: `tests/e2e/task-completion-workflow.test.ts`

```typescript
describe('Task Completion Workflow (E2E)', () => {
  it('maintains consistency through full TodoWrite ‚Üí Hook ‚Üí AC Sync flow', async () => {
    // Step 1: TodoWrite marks task complete
    await todoWrite.markTaskComplete('T-001');

    // Step 2: Verify checkboxes marked (SSOT updated)
    const tasks = await fs.readFile(tasksPath, 'utf-8');
    expect(tasks).toMatch(/- \[x\] Step 1/);
    expect(tasks).toMatch(/- \[x\] Step 2/);

    // Step 3: Verify header marker added (derived state computed)
    expect(tasks).toContain('‚úÖ COMPLETE');

    // Step 4: Verify ACs synced
    const spec = await fs.readFile(specPath, 'utf-8');
    expect(spec).toContain('- [x] **AC-US1-01**');

    // Step 5: Validate consistency
    const validation = await validateTaskConsistency(incrementId);
    expect(validation.errors).toHaveLength(0);
  });

  it('prevents inconsistency from manual edits', async () => {
    // Step 1: Human manually adds ‚úÖ COMPLETE without marking checkboxes
    await fs.writeFile(tasksPath, `
### T-001: Task name ‚úÖ COMPLETE  ‚Üê Manual edit (wrong!)

**Implementation**:
- [ ] Step 1  ‚Üê Forgot to mark
- [ ] Step 2
    `);

    // Step 2: Pre-commit hook catches it
    const result = await execAsync('git add . && git commit -m "test"', { reject: false });
    expect(result.exitCode).toBe(1);
    expect(result.stderr).toContain('Task validation failed');

    // Step 3: Developer runs fix
    await execAsync('npm run fix-tasks');

    // Step 4: Verify marker removed
    const fixed = await fs.readFile(tasksPath, 'utf-8');
    expect(fixed).not.toContain('‚úÖ COMPLETE');

    // Step 5: Now commit succeeds
    const retry = await execAsync('git add . && git commit -m "test"');
    expect(retry.exitCode).toBe(0);
  });
});
```

---

## üìä Implementation Roadmap

### Phase 1: Foundation (Week 1)

**Goal**: Implement TaskStateManager and validation

- [ ] Create `src/core/increment/task-state-manager.ts`
- [ ] Write unit tests (20+ test cases)
- [ ] Update `detectCompletedTasks()` to use TaskStateManager
- [ ] Test with increment 0037

**Success Criteria**: All 85 tasks validate correctly

---

### Phase 2: Automation (Week 2)

**Goal**: Auto-fix inconsistencies in hooks

- [ ] Enhance `update-tasks-md.ts` to auto-fix headers
- [ ] Add integration tests for auto-fix
- [ ] Test with 5 increments
- [ ] Document behavior in CLAUDE.md

**Success Criteria**: Hook auto-fixes 100% of inconsistencies

---

### Phase 3: Prevention (Week 3)

**Goal**: Block inconsistencies at source

- [ ] Create Git pre-commit hook
- [ ] Add CI/CD validation workflow
- [ ] Update TodoWrite to use TaskStateManager
- [ ] Add E2E tests

**Success Criteria**: Impossible to commit inconsistent tasks

---

### Phase 4: Migration (Week 4)

**Goal**: Apply to all existing increments

- [ ] Run validation on all increments
- [ ] Auto-fix any inconsistencies found
- [ ] Generate migration report
- [ ] Update documentation

**Success Criteria**: 100% of increments consistent

---

## üéØ Success Metrics

### Before Implementation

```
Inconsistency Rate: 25% (21/85 tasks)
Detection: Manual scan required
Fix: Manual checkbox marking
Prevention: None (can happen again)
Confidence: Low
```

### After Implementation

```
Inconsistency Rate: 0% (enforced)
Detection: Automatic (hook + pre-commit + CI)
Fix: Automatic (hook auto-fixes)
Prevention: Multiple layers (can't happen)
Confidence: 100%
```

---

## üîí Long-Term Guarantees

### Guarantee 1: Single Source of Truth

**Implementation checkboxes are the ONLY place to mark completion**

‚úÖ Header markers are read-only (computed from checkboxes)
‚úÖ Status lines deprecated (removed from templates)
‚úÖ TodoWrite only marks checkboxes (never headers)

### Guarantee 2: Automatic Consistency

**Hooks enforce consistency on every execution**

‚úÖ Auto-fix runs on every hook execution
‚úÖ Auto-fix runs on every git commit
‚úÖ Auto-fix runs on every CI/CD build

### Guarantee 3: Impossible to Break

**Multiple validation layers prevent inconsistencies**

‚úÖ Hook validation (auto-fixes)
‚úÖ Pre-commit validation (blocks commits)
‚úÖ CI/CD validation (blocks PRs)
‚úÖ E2E tests (verify full workflow)

---

## ‚úÖ Conclusion

**Current State**: Fixed immediate issue with strict validation

**Long-Term Solution**: Architectural redesign with multiple enforcement layers

**Key Insight**: The problem isn't the detection logic - it's the architecture allowing multiple sources of truth

**The Fix**: Make implementation checkboxes the SSOT, derive everything else, and enforce consistency at every entry point

**Confidence**: This solution makes inconsistencies **architecturally impossible**

---

**Next Step**: Implement TaskStateManager and write comprehensive tests
