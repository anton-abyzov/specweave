# Prompt Logging Architecture

**Feature**: Automatic logging of all user prompts to appropriate increment folders

**Created**: 2025-11-13
**Increment**: 0031-external-tool-status-sync

---

## Overview

SpecWeave will automatically log every user prompt to the appropriate increment's `logs/` folder, organized by day, with exact preservation of prompt text and any attachments (images, files).

## Requirements

1. ✅ **Automatic**: No user action needed - happens on EVERY prompt
2. ✅ **Exact preservation**: Prompt logged character-for-character (including typos, formatting)
3. ✅ **Smart increment detection**: Finds correct active increment automatically
4. ✅ **Daily organization**: One folder per day (YYYY-MM-DD)
5. ✅ **Asset management**: Images/files saved to assets/ subfolder
6. ✅ **Discipline-aware**: Respects 1-2 active increment rule
7. ✅ **Cross-platform**: Works on local, VM, claude.ai/code
8. ✅ **Non-blocking**: Doesn't slow down or interrupt prompt processing
9. ✅ **Configurable**: Can disable via config.json

---

## Directory Structure

### Standard Layout

```
.specweave/increments/0031-external-tool-status-sync/
├── spec.md
├── plan.md
├── tasks.md
├── reports/
├── scripts/
└── logs/                           # NEW! Automatic prompt logs
    ├── 2025-11-13/                 # Daily folder (YYYY-MM-DD)
    │   ├── session.md              # All prompts for this day (appended)
    │   └── assets/                 # Images, screenshots, files
    │       ├── screenshot-001.png
    │       ├── diagram-002.svg
    │       └── file-003.pdf
    ├── 2025-11-14/
    │   ├── session.md
    │   └── assets/
    └── README.md                   # Logs index (auto-generated)
```

### Orphaned Logs (No Active Increment)

When no increment is active, prompts go to orphaned logs:

```
.specweave/logs/orphaned/
├── 2025-11-13/
│   ├── session.md
│   └── assets/
└── README.md
```

---

## Session Log Format

### session.md Structure

```markdown
# Session Log - 2025-11-13

Generated by SpecWeave automatic prompt logging.
Increment: 0031-external-tool-status-sync

---

## 14:23:45 - User Prompt

you MUST support logs of a user in the increment, meaning there MUST be a separate folder logs and then folders inside for each day with kind of main md file which append user promprt exactly as it is, (for eacmple, this my prompt MUST be exactly as it's here), so prompts are appended to this file, and images are also saved in this folder (maybe in assets folder) . Ultrathink on it, make sure if specweave is installed for the root folder, it will do this for each and every use rprompt!

**Attachments**: None

---

## 14:28:12 - User Prompt

Let's implement the authentication service now

**Attachments**:
- `assets/screenshot-001.png` - Database schema diagram
- `assets/requirements-002.pdf` - Requirements doc

---

## 15:45:30 - User Prompt

Fix the bug in auth-service.ts line 42

**Attachments**: None

---
```

### Key Features

- **Timestamp**: HH:MM:SS for each prompt
- **Exact text**: Character-for-character preservation
- **Attachments**: List with relative paths to assets/
- **Separator**: `---` between prompts
- **Metadata header**: Date, increment ID

---

## Hook Architecture

### Hook Type: PrePromptSubmit

Claude Code provides a `PrePromptSubmit` hook that fires BEFORE the prompt is processed by the LLM. This is perfect for logging.

### Hook Registration

**File**: `plugins/specweave/hooks/hooks.json`

```json
{
  "hooks": [
    {
      "type": "PrePromptSubmit",
      "script": "prompt-submit.sh",
      "description": "Log user prompts to active increment"
    },
    {
      "type": "PostToolUse",
      "script": "post-task-completion.sh",
      "description": "Post-task automation (existing)"
    }
  ]
}
```

### Hook Script Flow

**File**: `plugins/specweave/hooks/prompt-submit.sh`

```bash
#!/bin/bash

# 1. Check if logging is enabled
if ! jq -e '.logging.enabled == true' .specweave/config.json > /dev/null 2>&1; then
  exit 0  # Silently skip if disabled
fi

# 2. Find active increment
ACTIVE_INCREMENT=$(find .specweave/increments -name "metadata.json" \
  -exec jq -r 'select(.status == "active") | .id' {} \; | head -1)

# 3. Determine log directory
if [ -z "$ACTIVE_INCREMENT" ]; then
  LOG_DIR=".specweave/logs/orphaned"
else
  LOG_DIR=".specweave/increments/$ACTIVE_INCREMENT/logs"
fi

# 4. Create daily folder
DATE=$(date +%Y-%m-%d)
DAILY_DIR="$LOG_DIR/$DATE"
mkdir -p "$DAILY_DIR/assets"

# 5. Log the prompt
node -e "
const { PromptLogger } = require('./dist/src/core/logging/prompt-logger.js');
const logger = new PromptLogger(process.cwd());
logger.logPrompt('$DAILY_DIR', process.env.USER_PROMPT, process.env.ATTACHMENTS);
"
```

### Environment Variables (Provided by Claude Code)

Claude Code hook environment includes:
- `USER_PROMPT` - The exact text user typed
- `ATTACHMENTS` - JSON array of attachment paths
- `TIMESTAMP` - ISO 8601 timestamp

---

## TypeScript Implementation

### PromptLogger Class

**File**: `src/core/logging/prompt-logger.ts`

```typescript
import fs from 'fs-extra';
import path from 'path';

export interface Attachment {
  path: string;
  name: string;
  type: string;
}

export class PromptLogger {
  constructor(private workingDir: string) {}

  /**
   * Log a user prompt to the daily session file
   */
  async logPrompt(
    dailyDir: string,
    promptText: string,
    attachments: Attachment[] = []
  ): Promise<void> {
    const sessionFile = path.join(dailyDir, 'session.md');
    const assetsDir = path.join(dailyDir, 'assets');

    // Ensure directories exist
    await fs.ensureDir(assetsDir);

    // Get timestamp
    const now = new Date();
    const time = now.toTimeString().slice(0, 8); // HH:MM:SS

    // Create session file header if new file
    if (!await fs.pathExists(sessionFile)) {
      const date = now.toISOString().slice(0, 10); // YYYY-MM-DD
      const header = this.createSessionHeader(date, dailyDir);
      await fs.writeFile(sessionFile, header);
    }

    // Build prompt entry
    const entry = this.buildPromptEntry(time, promptText, attachments, assetsDir);

    // Append to session file
    await fs.appendFile(sessionFile, entry);

    // Copy attachments to assets/
    await this.copyAttachments(attachments, assetsDir);
  }

  /**
   * Create session file header
   */
  private createSessionHeader(date: string, dailyDir: string): string {
    const incrementId = this.extractIncrementId(dailyDir);

    return `# Session Log - ${date}

Generated by SpecWeave automatic prompt logging.
${incrementId ? `Increment: ${incrementId}` : 'Location: Orphaned logs (no active increment)'}

---

`;
  }

  /**
   * Build a single prompt entry
   */
  private buildPromptEntry(
    time: string,
    promptText: string,
    attachments: Attachment[],
    assetsDir: string
  ): string {
    let entry = `## ${time} - User Prompt\n\n`;
    entry += `${promptText}\n\n`;

    if (attachments.length > 0) {
      entry += `**Attachments**:\n`;
      attachments.forEach((att, idx) => {
        const assetPath = this.getAssetFilename(att, idx + 1);
        entry += `- \`assets/${assetPath}\` - ${att.name}\n`;
      });
    } else {
      entry += `**Attachments**: None\n`;
    }

    entry += `\n---\n\n`;
    return entry;
  }

  /**
   * Copy attachments to assets folder
   */
  private async copyAttachments(
    attachments: Attachment[],
    assetsDir: string
  ): Promise<void> {
    for (let i = 0; i < attachments.length; i++) {
      const att = attachments[i];
      const destFilename = this.getAssetFilename(att, i + 1);
      const destPath = path.join(assetsDir, destFilename);

      await fs.copy(att.path, destPath);
    }
  }

  /**
   * Generate numbered asset filename
   */
  private getAssetFilename(att: Attachment, index: number): string {
    const ext = path.extname(att.name);
    const basename = path.basename(att.name, ext);
    const typePrefix = this.getTypePrefix(att.type);

    return `${typePrefix}-${String(index).padStart(3, '0')}${ext}`;
  }

  /**
   * Get prefix based on file type
   */
  private getTypePrefix(type: string): string {
    if (type.startsWith('image/')) return 'screenshot';
    if (type === 'application/pdf') return 'document';
    return 'file';
  }

  /**
   * Extract increment ID from log directory path
   */
  private extractIncrementId(dailyDir: string): string | null {
    const match = dailyDir.match(/increments\/([^\/]+)\/logs/);
    return match ? match[1] : null;
  }

  /**
   * Find active increment
   */
  async findActiveIncrement(): Promise<string | null> {
    const incrementsDir = path.join(this.workingDir, '.specweave/increments');

    if (!await fs.pathExists(incrementsDir)) {
      return null;
    }

    const dirs = await fs.readdir(incrementsDir);

    for (const dir of dirs) {
      const metadataPath = path.join(incrementsDir, dir, 'metadata.json');

      if (await fs.pathExists(metadataPath)) {
        const metadata = await fs.readJson(metadataPath);

        if (metadata.status === 'active') {
          return dir;
        }
      }
    }

    return null;
  }
}
```

---

## Configuration

### Config Schema

**File**: `.specweave/config.json`

```json
{
  "logging": {
    "enabled": true,
    "logUserPrompts": true,
    "logAssistantResponses": false,
    "includeAttachments": true,
    "orphanedLogsFolder": ".specweave/logs/orphaned",
    "maxDailyLogSizeMB": 100
  }
}
```

### Schema Definition

**File**: `src/core/schemas/specweave-config.schema.json`

```json
{
  "logging": {
    "type": "object",
    "properties": {
      "enabled": {
        "type": "boolean",
        "default": true,
        "description": "Enable automatic prompt logging"
      },
      "logUserPrompts": {
        "type": "boolean",
        "default": true,
        "description": "Log user prompts to increment logs/"
      },
      "logAssistantResponses": {
        "type": "boolean",
        "default": false,
        "description": "Log Claude's responses (optional, increases size)"
      },
      "includeAttachments": {
        "type": "boolean",
        "default": true,
        "description": "Copy images/files to assets/ folder"
      },
      "orphanedLogsFolder": {
        "type": "string",
        "default": ".specweave/logs/orphaned",
        "description": "Where to log prompts when no increment is active"
      },
      "maxDailyLogSizeMB": {
        "type": "number",
        "default": 100,
        "description": "Max size of daily log file before rotation"
      }
    }
  }
}
```

---

## Active Increment Detection

### Algorithm

```typescript
/**
 * Find the appropriate increment for logging
 * Priority:
 * 1. Most recently modified active increment
 * 2. Single active increment
 * 3. null (log to orphaned/)
 */
async findIncrementForLogging(): Promise<string | null> {
  const incrementsDir = path.join(this.workingDir, '.specweave/increments');

  // Find all active increments
  const activeIncrements: Array<{id: string, lastActivity: Date}> = [];

  const dirs = await fs.readdir(incrementsDir);

  for (const dir of dirs) {
    const metadataPath = path.join(incrementsDir, dir, 'metadata.json');

    if (await fs.pathExists(metadataPath)) {
      const metadata = await fs.readJson(metadataPath);

      if (metadata.status === 'active') {
        activeIncrements.push({
          id: dir,
          lastActivity: new Date(metadata.lastActivity || metadata.created)
        });
      }
    }
  }

  // No active increments → orphaned logs
  if (activeIncrements.length === 0) {
    return null;
  }

  // Single active → use it
  if (activeIncrements.length === 1) {
    return activeIncrements[0].id;
  }

  // Multiple active (allowed: max 2) → use most recent
  activeIncrements.sort((a, b) =>
    b.lastActivity.getTime() - a.lastActivity.getTime()
  );

  return activeIncrements[0].id;
}
```

---

## Edge Cases

### 1. No Active Increment

**Scenario**: User runs SpecWeave without creating an increment

**Solution**: Log to `.specweave/logs/orphaned/YYYY-MM-DD/`

**Example**:
```
.specweave/logs/orphaned/
└── 2025-11-13/
    ├── session.md      # "What is SpecWeave?"
    └── assets/
```

### 2. Multiple Active Increments (Max 2)

**Scenario**: User has 2 active increments (e.g., feature + hotfix)

**Solution**: Use most recently modified (via `metadata.lastActivity`)

**Example**:
```
0016-feature (lastActivity: 2025-11-13 10:00) ← Older
0017-hotfix (lastActivity: 2025-11-13 14:00)  ← Newer (log here!)
```

### 3. Images and Attachments

**Scenario**: User uploads screenshot or file

**Solution**: Copy to `assets/` with numbered prefix

**Example**:
```
User uploads: "auth-flow.png"
→ Saved as: "logs/2025-11-13/assets/screenshot-001.png"

User uploads: "requirements.pdf"
→ Saved as: "logs/2025-11-13/assets/document-002.pdf"
```

### 4. Large Prompts

**Scenario**: User pastes 10,000 line code snippet

**Solution**: No truncation, save full text

**Safeguard**: Config option `maxDailyLogSizeMB` (default: 100MB)

### 5. Concurrent Prompts (Rare)

**Scenario**: Multiple Claude Code sessions for same project

**Solution**: File locking via `fs.appendFile` (atomic on most filesystems)

**Fallback**: If conflict detected, add unique suffix to timestamp

### 6. VM/Cloud Environments (claude.ai/code)

**Scenario**: Temporary filesystem, may not persist

**Solution**: Hook works the same (logs to `.specweave/`), user responsible for git commit

**Best Practice**: Encourage users to commit logs/ folder to git

---

## Performance Considerations

### Non-Blocking Design

- ✅ Hook runs asynchronously (doesn't block prompt processing)
- ✅ File I/O is append-only (fast)
- ✅ Attachment copying is async
- ✅ No LLM calls involved (pure file operations)

### Expected Performance

- **Prompt logging**: <10ms (append text to file)
- **Attachment copy**: <100ms per file (depends on size)
- **Overall impact**: Negligible (user won't notice)

### Optimization

- Use `fs.appendFile` (atomic, buffered)
- Lazy directory creation (only when needed)
- No mutex/locks needed (filesystem handles it)

---

## Security & Privacy

### Sensitive Data

**Risk**: User prompts may contain API keys, passwords, secrets

**Mitigations**:
1. ✅ Logs are in `.specweave/` (add to .gitignore if needed)
2. ✅ User can disable logging via config
3. ✅ No cloud upload (stays local)
4. ✅ README.md warning in logs/ folder

### .gitignore Recommendation

Users can choose to exclude logs from git:

```gitignore
# Option 1: Exclude ALL logs (never commit)
.specweave/**/logs/

# Option 2: Exclude only orphaned logs
.specweave/logs/orphaned/

# Option 3: Include logs (full audit trail)
# (don't add to .gitignore - commit everything)
```

---

## User Experience

### Automatic & Invisible

- ✅ User types prompt → logged automatically
- ✅ No confirmation dialog
- ✅ No notification spam
- ✅ Works silently in background

### Discovery

Users discover logs via:
1. **README.md** in `logs/` folder (auto-generated)
2. **Documentation** (CLAUDE.md, user guide)
3. **Status command**: `/specweave:status` (shows logs/ size)

### README.md (Auto-Generated)

**File**: `.specweave/increments/0031/logs/README.md`

```markdown
# Prompt Logs

This folder contains automatic logs of all user prompts for this increment.

## Structure

```
logs/
├── 2025-11-13/
│   ├── session.md      # All prompts for this day
│   └── assets/         # Images, screenshots, files
├── 2025-11-14/
│   └── session.md
└── README.md           # This file
```

## Purpose

- **Audit trail**: Review what was asked and when
- **Context preservation**: Understand past decisions
- **Debug tool**: Trace where certain implementations came from
- **Knowledge base**: Search past conversations

## Privacy Note

These logs contain YOUR prompts exactly as typed. They may include:
- Code snippets
- API keys or secrets (review before committing!)
- Personal information
- Project-specific details

**Recommendation**: Review logs before committing to git.

## Configuration

To disable logging, edit `.specweave/config.json`:

```json
{
  "logging": {
    "enabled": false
  }
}
```

## Generated by SpecWeave

Last updated: 2025-11-13 14:23:45
```

---

## Benefits

### For Users

- ✅ **Perfect audit trail**: Never lose context of what was asked
- ✅ **Debug conversations**: Understand why certain code was generated
- ✅ **Knowledge base**: Search past prompts for patterns
- ✅ **Compliance**: Some industries require conversation logs
- ✅ **Learning**: Review effective prompt engineering techniques

### For Teams

- ✅ **Onboarding**: New team members can review past conversations
- ✅ **Handoffs**: Transfer context when switching developers
- ✅ **Code reviews**: Understand the "why" behind implementations
- ✅ **Retrospectives**: Analyze what prompts led to bugs vs. successes

### For AI Training

- ✅ **Fine-tuning data**: Could use logs to train project-specific models
- ✅ **Prompt optimization**: Analyze which prompts were most effective
- ✅ **Context patterns**: Understand common workflows

---

## Implementation Phases

### Phase 1: Core Logging (P1)

- [x] Architecture design (this document)
- [ ] TypeScript PromptLogger class
- [ ] Hook script (prompt-submit.sh)
- [ ] Config schema update
- [ ] Hook registration
- [ ] Basic testing

### Phase 2: Attachments (P1)

- [ ] Image copying to assets/
- [ ] File attachment support
- [ ] Numbered filename generation
- [ ] Relative path references

### Phase 3: Polish (P2)

- [ ] Auto-generated README.md in logs/
- [ ] Status command integration (show logs/ size)
- [ ] Log rotation (when daily file > maxDailyLogSizeMB)
- [ ] Search utility (search logs for keywords)

### Phase 4: Optional Features (P3)

- [ ] Log assistant responses (optional config)
- [ ] Export to different formats (JSON, CSV)
- [ ] Analytics (most common prompts, time patterns)
- [ ] Integration with external logging tools

---

## Testing Strategy

### Unit Tests

**File**: `tests/unit/logging/prompt-logger.test.ts`

```typescript
describe('PromptLogger', () => {
  it('should create daily log directory', async () => {
    const logger = new PromptLogger('/tmp/test');
    await logger.logPrompt('/tmp/test/logs/2025-11-13', 'Hello world');

    expect(fs.existsSync('/tmp/test/logs/2025-11-13/session.md')).toBe(true);
  });

  it('should append prompts without overwriting', async () => {
    const logger = new PromptLogger('/tmp/test');
    await logger.logPrompt('/tmp/test/logs/2025-11-13', 'First prompt');
    await logger.logPrompt('/tmp/test/logs/2025-11-13', 'Second prompt');

    const content = fs.readFileSync('/tmp/test/logs/2025-11-13/session.md', 'utf-8');
    expect(content).toContain('First prompt');
    expect(content).toContain('Second prompt');
  });

  it('should copy attachments to assets/', async () => {
    const logger = new PromptLogger('/tmp/test');
    const attachments = [{
      path: '/tmp/test.png',
      name: 'test.png',
      type: 'image/png'
    }];

    await logger.logPrompt('/tmp/test/logs/2025-11-13', 'With image', attachments);

    expect(fs.existsSync('/tmp/test/logs/2025-11-13/assets/screenshot-001.png')).toBe(true);
  });
});
```

### Integration Tests

**File**: `tests/integration/logging/prompt-logging.test.ts`

```typescript
describe('Prompt Logging Integration', () => {
  it('should log to active increment', async () => {
    // Create active increment
    await createIncrement('0031-test', 'active');

    // Trigger hook
    await triggerPromptSubmitHook('Test prompt');

    // Verify log exists
    const logPath = '.specweave/increments/0031-test/logs/2025-11-13/session.md';
    expect(fs.existsSync(logPath)).toBe(true);

    const content = fs.readFileSync(logPath, 'utf-8');
    expect(content).toContain('Test prompt');
  });

  it('should log to orphaned when no active increment', async () => {
    // No active increments
    await clearActiveIncrements();

    // Trigger hook
    await triggerPromptSubmitHook('Orphaned prompt');

    // Verify orphaned log
    const logPath = '.specweave/logs/orphaned/2025-11-13/session.md';
    expect(fs.existsSync(logPath)).toBe(true);
  });
});
```

### E2E Tests

**File**: `tests/e2e/prompt-logging.spec.ts`

```typescript
import { test, expect } from '@playwright/test';

test('should log prompts automatically', async ({ page }) => {
  // Start Claude Code session
  await page.goto('file:///path/to/project');

  // Type a prompt
  await page.fill('[data-testid="prompt-input"]', 'Create a new feature');
  await page.click('[data-testid="submit-button"]');

  // Wait for hook to complete
  await page.waitForTimeout(1000);

  // Check log file exists
  const logPath = '.specweave/increments/0031-test/logs/2025-11-13/session.md';
  const logExists = await fs.pathExists(logPath);
  expect(logExists).toBe(true);

  // Verify content
  const content = await fs.readFile(logPath, 'utf-8');
  expect(content).toContain('Create a new feature');
});
```

---

## Documentation Updates

### CLAUDE.md

Add new section:

```markdown
## Prompt Logging

**AUTOMATIC FEATURE**: Every user prompt is logged to the appropriate increment's `logs/` folder.

**Structure**:
```
.specweave/increments/0031/logs/
├── 2025-11-13/
│   ├── session.md      # All prompts for this day
│   └── assets/         # Images, screenshots
└── README.md
```

**Benefits**:
- ✅ Perfect audit trail
- ✅ Context preservation
- ✅ Debug tool
- ✅ Knowledge base

**Configuration**: Edit `.specweave/config.json` to disable:

```json
{
  "logging": {
    "enabled": false
  }
}
```

**See**: [Prompt Logging Guide](https://spec-weave.com/docs/learn/prompt-logging)
```

### User Guide

**File**: `.specweave/docs/public/guides/prompt-logging.md`

Create comprehensive guide covering:
- What is automatic prompt logging
- Where logs are stored
- How to review logs
- Privacy considerations
- Configuration options
- Search and analytics

---

## Conclusion

This architecture provides:

- ✅ **Automatic logging**: Zero user effort
- ✅ **Smart detection**: Finds correct increment
- ✅ **Exact preservation**: Character-for-character prompt storage
- ✅ **Asset management**: Images and files organized
- ✅ **Cross-platform**: Works everywhere (local, VM, cloud)
- ✅ **Non-invasive**: No performance impact
- ✅ **Configurable**: Can disable if needed
- ✅ **Privacy-aware**: Logs stay local

**Next Steps**: Implement Phase 1 (Core Logging)

---

**Architecture Status**: APPROVED ✅
**Ready for Implementation**: YES ✅
